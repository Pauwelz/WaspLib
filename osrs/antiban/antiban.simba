

{$DEFINE WL_ANTIBAN_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osrs.simba}
{$ENDIF}

type
  PAntibanTask = ^TAntibanTask;
  PBreakTask = ^TBreakTask;
  PSleepTask = ^TSleepTask;
  PAntibanTaskArray = array of PAntibanTask;
  PAntibanBreakArray = array of PBreakTask;

  TAntibanMethod = procedure of object;

  TAntibanTask = record
    Method: TAntibanMethod;
    Interval: Double;
    StdVar: Double;
    Countdown: TCountDown;
  end;

  TBreakTask = record
    Interval: Double;
    Length: Double;
    LogoutChance: Double;
    StdVar: Double;
    Next, Previous: Double;
  end;

  TSleepTask = record
    Time: String;
    Length: Double;
    Randomness: String;
    LogoutChance: Double;
    StdVar: Double;
    Next: Double;
  end;


  TAntiban = record
    DoingAntiban: Boolean;
    Debugging: Boolean;
    DebugRandoms: Boolean;

    Skills: array of ERSSkill;

    Zoom: record
      Min, Max: Integer;
    end;

    Tasks:  array of TAntibanTask;
    Breaks: array of TBreakTask;
    Sleeps: array of TSleepTask;

    OnStartTask,  OnFinishTask:  procedure(task: PAntibanTask) of object;
    OnStartBreak, OnFinishBreak: procedure(task: PBreakTask)   of object;
    OnStartSleep, OnFinishSleep: procedure(task: PSleepTask)   of object;

    OnBreaking: procedure(task: PBreakTask; var countdown: TCountdown) of object;
    OnSleeping: procedure(task: PSleepTask; var countdown: TCountdown) of object;
  end;

function TAntiban.TimeRunningAtClock(time: String; randomness: Double = 0.10): Int64;
var
  current, res: TDateTime;
begin
  current := TDateTime.CreateFromSystem();

  res := (TDateTime.CreateFromISO(current.Date.ToString('YYYY-MM-DD') + 'T' + time)) - current;
  if (res < 0) then res += 1;

  Result := GetTimeRunning() + Trunc(res * ONE_DAY);

  Result += Trunc(GaussRand(0, randomness * 10 * ONE_DAY));
  Result := Max(0, Result);
end;


function TAntiban.GetActiveTasks(): PAntibanTaskArray;
var
  i: Integer;
begin
  for i := 0 to High(Self.Tasks) do
    if not Self.Tasks[i].Countdown.IsPaused then
      Result += @Self.Tasks[i];
end;



procedure TAntiban._UpdateTask(idx: Integer; method: TAntibanMethod; interval, randomness: Double);
begin
  Self.Tasks[idx].Interval := interval;
  Self.Tasks[idx].Method := @method;
  Self.Tasks[idx].StdVar := randomness;
  Self.Tasks[idx].Countdown.Start(Random(Trunc(Abs(GaussRand(Self.Tasks[idx].Interval, Self.Tasks[idx].Interval * Self.Tasks[idx].StdVar)))));
end;

procedure TAntiban._UpdateBreak(idx: Integer; interval, length, randomness, logoutChance: Double);
begin
  Self.Breaks[idx].Interval := interval;
  Self.Breaks[idx].Length := length;
  Self.Breaks[idx].StdVar := randomness;
  Self.Breaks[idx].LogoutChance := logoutChance;
  Self.Breaks[idx].Next := GetTimeRunning() + Abs(GaussRand(Self.Breaks[idx].Interval, Self.Breaks[idx].Interval * Self.Breaks[idx].StdVar));
end;

procedure TAntiban._UpdateSleep(idx: Integer; time: String; length, randomness, logoutChance: Double);
begin
  Self.Sleeps[idx].Time := time;
  Self.Sleeps[idx].Length := length;
  Self.Sleeps[idx].StdVar := randomness;
  Self.Sleeps[idx].LogoutChance := logoutChance;
  Self.Sleeps[idx].Next := Self.TimeRunningAtClock(Self.Sleeps[idx].Time, Self.Sleeps[idx].StdVar);
end;



procedure TAntiban.AddTask(method: TAntibanMethod; interval: Double; randomness: Double = 0.2);
var
  len: Integer;
begin
  len := Length(Self.Tasks);
  SetLength(Self.Tasks, len+1);
  Self._UpdateTask(len, @method, interval, randomness);
end;


procedure TAntiban.AddBreak(length, interval: Double; randomness: Double = 0.2; logoutChance: Double = 0.33);
var
  len: Integer;
begin
  len := System.Length(Self.Breaks);
  SetLength(Self.Breaks, len+1);
  Self._UpdateBreak(len, interval, length, randomness, logoutChance);
end;


procedure TAntiban.AddSleep(time: String; length: Double; randomness: Double = 0.1; logoutChance: Double = 0.5);
var
  len: Integer;
begin
  len := System.Length(Self.Sleeps);
  SetLength(Self.Sleeps, len+1);
  Self._UpdateSleep(len, time, length, randomness, logoutChance);
end;



procedure TAntiban.TakeBreak(var task: TBreakTask);
var
  countdown: TCountDown;
  i: Integer;
  activeTasks: PAntibanTaskArray;
begin
  activeTasks := Self.GetActiveTasks();
  for i := 0 to High(activeTasks) do
    activeTasks[i]^.countdown.Pause();

  countdown.Start(Abs(Round(GaussRand(task.Length, task.Length * task.StdVar))));

  WriteLn GetDebugLn('Antiban', 'Taking a break for ' + FormatMilliseconds(countdown.Remaining, MINUTES_FORMAL));

  if (@Self.OnStartBreak <> nil) then
    Self.OnStartBreak(@task);

  if RandomBoolean(task.LogoutChance) then
  begin
    WriteLn GetDebugLn('Antiban', 'Logging out.');
    Logout.Logout();
  end;

  if RandomBoolean(0.50) then
    RSClient.LoseFocus();

  repeat
    if (Inc(i) mod 12 = 0) then
      WriteLn GetDebugLn('Antiban', 'Break time remaining: ' + FormatMilliseconds(countdown.Remaining, MINUTES_FORMAL));

    if (@Self.OnBreaking <> nil) then //callback runs every 5 seconds
      Self.OnBreaking(@task, countdown);

    Sleep(Round(Min(countdown.Remaining, 5 * ONE_SECOND)));
  until countdown.IsFinished;

  WriteLn GetDebugLn('Antiban', 'Break finished');

  if (@Self.OnFinishBreak <> nil) then
    Self.OnFinishBreak(@task);

  // Offset all tasks & breaks
  for i := 0 to High(Self.Breaks) do
    Self.Breaks[i].Next += Time() - (countdown.FFinishTime - countdown.FLength );

  for I := 0 to High(activeTasks) do
    activeTasks[i]^.countdown.Resume();

  // Setup next time this break happens
  task.Next := GetTimeRunning() + Abs(GaussRand(task.Interval, task.Interval * task.StdVar));
end;


procedure TAntiban.TakeSleep(var task: TSleepTask);
var
  countdown: TCountDown;
  i: Integer;
  activeTasks: PAntibanTaskArray;
  marker: UInt64;
begin
  activeTasks := Self.GetActiveTasks();
  for i := 0 to High(activeTasks) do
    activeTasks[i]^.countdown.Pause();

  countdown.Start(Abs(Round(GaussRand(task.Length, task.Length * task.StdVar))));
  WriteLn GetDebugLn('Antiban', 'Sleeping for ' + FormatMilliseconds(countdown.Remaining, TIME_FORMAL));

  if @Self.OnStartSleep <> nil then Self.OnStartSleep(@task);

  if RandomBoolean(task.LogoutChance) then
  begin
    WriteLn GetDebugLn('Antiban', 'Logging out.');
    Logout.Logout();
  end;

  if RandomBoolean(0.7) then RSClient.LoseFocus();

  repeat
    if Time() > marker  then
    begin
      WriteLn GetDebugLn('Antiban', 'Sleep time remaining: ' + FormatMilliseconds(countdown.Remaining, TIME_FORMAL));
      //OnSleeping callback only runs every 5 mins.
      if (@Self.OnSleeping <> nil) then
        Self.OnSleeping(@task, countdown);
      marker := Time() + 5 * ONE_MINUTE;
    end;

    Sleep(Round(Min(countdown.Remaining, 5 * ONE_SECOND)));
  until countdown.IsFinished;

  WriteLn GetDebugLn('Antiban', 'Sleep finished.');

  if (@Self.OnFinishSleep <> nil) then
    Self.OnFinishSleep(@task);

  //Offset all tasks & breaks
  for i := 0 to High(Self.Breaks) do
    Self.Breaks[i].Next += Time() - (countdown.FFinishTime - countdown.FLength);

  for i := 0 to High(activeTasks) do
    activeTasks[i]^.countdown.Resume();

  // Schedule next time this sleep will happen
  task.Next := Self.TimeRunningAtClock(task.Time, task.StdVar);
  WriteLn('TakeSleep Next: ', task);
end;



function TAntiban.DoTask(): Boolean;
var
  i: Int32;
  task: PAntibanTask;
  activeTasks: PAntibanTaskArray;
begin
  activeTasks := Self.GetActiveTasks();
  for i := 0 to High(activeTasks) do
    activeTasks[i]^.Countdown.Pause();

  for i := 0 to High(activeTasks) do
  begin
    task := activeTasks[i];

    if task^.Countdown.Remaining = 0 then
    begin
      if (@Self.OnStartTask <> nil) then
        Self.OnStartTask(Task);

      task^.Method();
      task^.Countdown.Start(Trunc(Abs(GaussRand(task^.Interval, task^.Interval * task^.StdVar))));
      task^.Countdown.Pause();

      if (@Self.OnFinishTask <> nil) then
        Self.OnFinishTask(Task);

      Result := True;
    end;
  end;

  for i := 0 to High(activeTasks) do
    activeTasks[i]^.Countdown.Resume();
end;


function TAntiban.DoBreak(): Boolean;
var
  i: Integer;
  t: UInt64;
begin
  t := GetTimeRunning();
  for i := 0 to High(Self.Breaks) do
    if t > Self.Breaks[i].Next then
    begin
      Self.TakeBreak(Self.Breaks[i]);
      Result := True;
      // Restart loop
      i := -1;
      t := GetTimeRunning();
    end;
end;


function TAntiban.DoSleep(): Boolean;
var
  i: Integer;
  t: UInt64;
begin
  t := GetTimeRunning();
  for i := 0 to High(Self.Sleeps) do
    if t > Self.Sleeps[i].Next then
    begin
      Self.TakeSleep(Self.Sleeps[i]);
      Result := True;
      // Restart loop
      i := -1;
      t := GetTimeRunning();
    end;
end;



function TAntiban.DoAntiban(checkTasks, checkBreaks, checkSleeps: Boolean = True): Boolean;
begin
  if Self.DoingAntiban then
    Exit;

  Self.DoingAntiban := True;
  Logger.TimeRunning.Pause();
  Activity.Pause();

  if checkTasks  and Self.DoTask()  then Result := True;
  if checkBreaks and Self.DoBreak() then Result := True;
  if checkSleeps and Self.DoSleep() then Result := True;

  if not RSClient.IsLoggedIn() then
    Login.DoLogin(Profiles.GetPlayer());

  Self.DoingAntiban := False;
  Logger.TimeRunning.Start();
  Activity.Resume();
end;



function TAntiban.TimeUntilBreak(task: TBreakTask): String;
begin
  Result := FormatMilliseconds(Max(0, Round(task.Next - GetTimeRunning())), True);
end;


function TAntiban.TimeUntilSleep(task: TSleepTask): String;
begin
  Result := FormatMilliseconds(Max(0, Round(task.Next - GetTimeRunning())), True);
end;


procedure TAntiban.SimulateBreaks(bottingDays: UInt64 = 1000);
var
  active, inactive, len, prev: Double;
  i: Int32;
  task: PBreakTask;
begin
  while (active + inactive < bottingDays * ONE_DAY) do
  begin
    task := @Self.Breaks[0];
    for I := 0 to High(Self.Breaks) do
      if Self.Breaks[i].Next < task^.Next then
        task := @Self.Breaks[i];

    len := Abs(GaussRand(task^.Length, task^.Length * task^.StdVar));
    active += task^.Next - Prev;
    inactive += len;

    for i := 0 to High(Self.Breaks) do
      Self.Breaks[i].Next += len;

    prev := task^.Next;
    task^.Next += Abs(GaussRand(task^.Interval, task^.Interval * task^.StdVar));
  end;

  inactive /= bottingDays;
  active /= bottingDays;
  WriteLn('Running for ', FormatMilliseconds(Round(active), TIME_FORMAL), ' per day, on average.');
end;


procedure TAntiban.WalkingTasks();
begin
  //overriden later.
end;

var

  Antiban: TAntiban;
