

{$DEFINE WL_LOGIN_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

const

  LOGIN_MESSAGES = [
    'Welcome to ',
    'Connecting to server',
    'Invalid credentials',
    'Incorrect username or password',
    'You need a skill total of',
    'your username/email',
    'Error connecting to server',
    'Your account has not logged out',
    'Login server offline',
    'The game servers are currently being updated',
    'RuneScape has been updated!',
    'Error loading your profile',
    'Connection timed out',
    'You were disconnected',
    'Login limit exceeded',
    'This world is full',
    'Your account has been',
    'You need a members'' account',
    'You are standing in a members-only area',
    'move your character to a non-members area',
    'Authenticator'
  ];

type

  ERSLoginMode    = enum(UNKNOWN, LEGACY, LAUNCHER);
  ERSLoginButton  = enum(LAUNCHER, EXISTING_USER, LOGIN, RETRY, OKAY, CONTINUE);
  ERSLoginInput   = enum(USERNAME, PASSWORD);
  ERSLoginMessage = enum(
    UNKNOWN,
    WELCOME, CONNECTING, INVALID, INCORRECT, SKILL_TOTAL, ENTER_CREDENTIALS,
    ERROR_CONNECTING, ACCOUNT_ONLINE, SERVER_OFFLINE, BEING_UPDATED,
    GAME_UPDATED, ERROR_LOADING, TIMED_OUT, DISCONNECTED,

    LIMIT_EXCEEDED, WORLD_FULL, BANNED, NOT_MEMBER, ON_MEMBER_AREA,
    ON_MEMBER_AREA2,

    AUTHENTICATOR
  );


  TRSLogin = record
    Bounds: TBox;

    Inputs: array [ERSLoginInput] of TBox;
    Buttons: array [ERSLoginButton] of record
      Text: String;
      Bounds: TBox;
      Bold: Boolean;
    end;

    Mode: ERSLoginMode;
    Attempts: Integer;
    ClearInputs: Boolean;
  end;


procedure TRSLogin.Setup();
begin
  Self.Bounds.X1 := Target.Width div 2 - 176;
  Self.Bounds.Y1 := Target.Bounds.Y1 + 172;
  Self.Bounds.X2 := Target.Width div 2 + 176;
  Self.Bounds.Y2 := Self.Bounds.Y1 + 194;

  with Self.Inputs[ERSLoginInput.USERNAME] do
  begin
    X1 := Self.Bounds.X1 + 106;
    Y1 := Self.Bounds.Y1 + 69;
    X2 := X1 + 200;
    Y2 := Y1 + 16;
  end;

  with Self.Inputs[ERSLoginInput.PASSWORD] do
  begin
    X1 := Self.Bounds.X1 + 138;
    Y1 := Self.Bounds.Y1 + 86;
    X2 := X1 + 204;
    Y2 := Y1 + 13;
  end;

  with Self.Buttons[ERSLoginButton.LAUNCHER] do
  begin
    Bounds.X1 := Self.Bounds.X1 + 72;
    Bounds.Y1 := Self.Bounds.Y1 + 62;
    Bounds.X2 := Bounds.X1 + 207;
    Bounds.Y2 := Bounds.Y1 + 57;
    Text := '';
  end;

  with Self.Buttons[ERSLoginButton.EXISTING_USER] do
  begin
    Bold := True;
    Bounds.X1 := Self.Bounds.X1 + 188;
    Bounds.Y1 := Self.Bounds.Y1 + 103;
    Bounds.X2 := Bounds.X1 + 134;
    Bounds.Y2 := Bounds.Y1 + 32;
    Text := 'Existing User';
  end;

  with Self.Buttons[ERSLoginButton.LOGIN] do
  begin
    Bold := True;
    Bounds.X1 := Self.Bounds.X1 + 28;
    Bounds.Y1 := Self.Bounds.Y1 + 133;
    Bounds.X2 := Bounds.X1 + 134;
    Bounds.Y2 := Bounds.Y1 + 32;
    Text := 'Login';
  end;

  with Self.Buttons[ERSLoginButton.RETRY] do
  begin
    Bounds.X1 := Self.Bounds.X1 + 108;
    Bounds.Y1 := Self.Bounds.Y1 + 88;
    Bounds.X2 := Self.Bounds.X2 - 110;
    Bounds.Y2 := Bounds.Y1 + 32;
    Text := 'Try again';
  end;

  with Self.Buttons[ERSLoginButton.OKAY] do
  begin
    Bounds.X1 := Self.Bounds.X1 + 109;
    Bounds.Y1 := Self.Bounds.Y1 + 113;
    Bounds.X2 := Bounds.X1 + 134;
    Bounds.Y2 := Bounds.Y1 + 32;
    Text := 'Ok';
    Bold := True;
  end;
end;



function TRSLogin.FindButton(button: ERSLoginButton): Boolean;
begin
  if button = ERSLoginButton.LAUNCHER then
  begin
    if not InRange(Target.CountColor($FFFFFF, 0, Self.Buttons[ERSLoginButton.LAUNCHER].Bounds), 500, 550) then
      Exit;

    Exit(True);
  end;

  if Self.Buttons[button].Bold then
    Exit(Self.Buttons[button].Text = OCR.Recognize(Self.Buttons[button].Bounds, RSFonts.BOLD_SHADOW, [$FFFFFF], 0));

  Result := Self.Buttons[button].Text = OCR.Recognize(Self.Buttons[button].Bounds, RSFonts.PLAIN_12, [$FFFFFF], 0);
end;


function TRSLogin.ClickButton(button: ERSLoginButton): Boolean;
begin
  if not Self.FindButton(button) then Exit;
  Result := True;
  Mouse.Click(Self.Buttons[button].Bounds, EMouseButton.LEFT);
end;



function TRSLogin.SelectInput(field: ERSLoginInput): Boolean;
begin
  if SleepUntil(Target.HasColor($00FFFF, 0, 8, Self.Inputs[field]), 30, 100) then
    Exit(True);

  if RandomBoolean(0.5) then
    Keyboard.KeyPress(EKeyCode.TAB)
  else
    with Self.Inputs[field] do
      Mouse.Click([X1, Y1, X2, Y2-3], EMouseButton.LEFT);

  Result := SleepUntil(Target.HasColor($00FFFF, 0, 8, Self.Inputs[field]), 30, 600);
end;


function TRSLogin.InputIsFilled(field: ERSLoginInput): Boolean;
begin
  Result := Target.HasColor($FFFFFF, 0, 1, Self.Inputs[field]);
end;


function TRSLogin.ClearInput(field: ERSLoginInput): Boolean;
begin
  if not Self.InputIsFilled(field) then Exit(True);
  if not Self.SelectInput(field) then Exit;

  Keyboard.KeyDown(EKeyCode.BACK);
  Result := SleepUntil(not Self.InputIsFilled(field), RandomMode(100, 50, 1500),  6000);
  Keyboard.KeyUp(EKeyCode.BACK);
end;


function TRSLogin.FillInput(field: ERSLoginInput; details: String): Boolean;
begin
  if Self.InputIsFilled(field) then Exit(True);
  if not Self.SelectInput(field) then Exit;

  Result := True;
  if details = '' then
    raise GetDebugLn('Login', 'Can''t fill ' + ToStr(field) + ' because the details are empty.');
  Keyboard.Send(details, EKeyCode.RETURN);
end;



function TRSLogin.GetMessage(): ERSLoginMessage;
var
  dialog: String;
  msg: ERSLoginMessage;
begin
  dialog := OCR.RecognizeLines(Self.Bounds, RSFonts.BOLD_SHADOW, [$00FFFF], 0).Join(' ');

  if dialog = '' then
    dialog := OCR.RecognizeLines(Self.Bounds, RSFonts.PLAIN_12, [$00FFFF], 0).Join(' ');

  if dialog = '' then
    dialog := OCR.RecognizeLines(Self.Bounds, RSFonts.BOLD_SHADOW, [$FFFFFF], 0).Join(' ');

  if dialog = '' then
    Exit;

  for msg := ERSLoginMessage.WELCOME to High(ERSLoginMessage)-1 do
    if dialog.Contains(LOGIN_MESSAGES[msg-1]) then
      Exit(msg);
end;



function TRSLogin.GetMode(): ERSLoginMode;
begin
  if Self.GetMessage() = ERSLoginMessage.WELCOME then
  begin
    if Self.FindButton(ERSLoginButton.EXISTING_USER) then
    begin
      WriteLn GetDebugLn('Login', 'Legacy client mode detected.');
      Exit(ERSLoginMode.LEGACY);
    end;

    if Self.FindButton(ERSLoginButton.LAUNCHER) then
    begin
      WriteLn GetDebugLn('Login', 'Launcher client mode detected.');
      Exit(ERSLoginMode.LAUNCHER);
    end;
  end;

  WriteLn GetDebugLn('Login', 'Failed to detect login mode.', ELogLevel.WARN);
end;



function TRSLogin.HandleWelcome(): Boolean;
begin
  if Self.Mode = ERSLoginMode.UNKNOWN then
    Self.Mode := Self.GetMode();

  case Self.Mode of
    ERSLoginMode.LEGACY:   if not Self.ClickButton(ERSLoginButton.EXISTING_USER) then Exit;
    ERSLoginMode.LAUNCHER: if not Self.ClickButton(ERSLoginButton.LAUNCHER) then Exit;
  end;

  Result := SleepUntil(Self.GetMessage() <> ERSLoginMessage.WELCOME, RandomMode(100, 50, 1500), 600);
end;


function TRSLogin.Back2Welcome(): Boolean;
begin
  if not Self.ClickButton(ERSLoginButton.OKAY) then Exit;
  Result := SleepUntil(Self.GetMessage() = ERSLoginMessage.WELCOME, RandomMode(100, 50, 1500), 600);
end;



function TRSLogin.EnterCredentials(username, password: String): Boolean;
begin
  if Self.ClearInputs then
  begin
    if not Self.ClearInput(ERSLoginInput.USERNAME) then Exit;
    if not Self.ClearInput(ERSLoginInput.PASSWORD) then Exit;
  end;

  if not Self.FillInput(ERSLoginInput.USERNAME, username) then Exit;
  if not Self.FillInput(ERSLoginInput.PASSWORD, password) then Exit;
  Result := SleepUntil(Self.GetMessage() <> ERSLoginMessage.ENTER_CREDENTIALS, RandomMode(100, 50, 1500), 600);
end;



function TRSLogin.Retry(msg: ERSLoginMessage): Boolean;
begin
  if not Self.ClickButton(ERSLoginButton.RETRY) then Exit;
  Self.ClearInputs := True;
  Result := SleepUntil(Self.GetMessage() <> msg, RandomMode(100, 50, 1500), 600);
end;


function TRSLogin.HandleError(msg: ERSLoginMessage): Boolean;
var
  time: Integer;
begin
  time := Random(10000, 20000) * Inc(Self.Attempts);

  if (msg = ERSLoginMessage.WORLD_FULL) or (Self.Attempts < 4) then
  begin
    WriteLn GetDebugLn('Login', 'Failed to login ' + ToStr(Self.Attempts) + ' times.', ELogLevel.WARN);
    WriteLn GetDebugLn('Login', 'Waiting ' + ToStr(time) + ' seconds before trying again.', ELogLevel.WARN);
    Sleep(time);
    Exit(True);
  end;

  if Self.Attempts = 4 then
  begin
    WriteLn GetDebugLn('Login', 'Failed to login ' + ToStr(Self.Attempts) + ' times.', ELogLevel.ERROR);
    WriteLn GetDebugLn('Login', 'Script will shutdown if we fail one more time.', ELogLevel.ERROR);
    WriteLn GetDebugLn('Login', 'Waiting ' + ToStr(time) + ' seconds before trying again.', ELogLevel.ERROR);
    Sleep(time);
    Exit(True);
  end;

  raise GetDebugLn('Login', 'Failed to login 10 times. Last login state: ' + ToStr(msg));
end;


function TRSLogin.HandleMessage(msg: ERSLoginMessage; username, password: String): Boolean;
begin
  case msg of
    ERSLoginMessage.WELCOME:           Result := Self.HandleWelcome();
    ERSLoginMessage.CONNECTING:        Result := SleepUntil(msg <> Self.GetMessage(), RandomMode(100, 50, 1500), 50000); //50 secs
    ERSLoginMessage.DISCONNECTED:      Result := Self.Back2Welcome();
    ERSLoginMessage.ENTER_CREDENTIALS: Result := Self.EnterCredentials(username, password);

    ERSLoginMessage.INVALID,
    ERSLoginMessage.INCORRECT:         Result := Self.Retry(msg);

    ERSLoginMessage.ERROR_CONNECTING,
    ERSLoginMessage.LIMIT_EXCEEDED,
    ERSLoginMessage.ACCOUNT_ONLINE,
    ERSLoginMessage.WORLD_FULL,
    ERSLoginMessage.TIMED_OUT:         Result := Self.HandleError(msg);

    ERSLoginMessage.SKILL_TOTAL:       raise GetDebugLn('Login', 'We are trying to login into a total level world you can''t login to.');
    ERSLoginMessage.SERVER_OFFLINE:    raise GetDebugLn('Login', 'Login server offline. The game is/was probably updated.');
    ERSLoginMessage.BEING_UPDATED:     raise GetDebugLn('Login', 'The game is being updated.');
    ERSLoginMessage.GAME_UPDATED:      raise GetDebugLn('Login', 'The game was updated.');
    ERSLoginMessage.ERROR_LOADING:     raise GetDebugLn('Login', 'Game loading error. It was probably updated.');
    ERSLoginMessage.BANNED:            raise GetDebugLn('Login', 'profile seems to be banned or disabled.');
    ERSLoginMessage.NOT_MEMBER:        raise GetDebugLn('Login', 'profile is not members and we are trying to login into a P2P world.');
    ERSLoginMessage.ON_MEMBER_AREA,
    ERSLoginMessage.ON_MEMBER_AREA2:   raise GetDebugLn('Login', 'profile is on a P2P area and we are trying to login into a F2P world.');

    ERSLoginMessage.AUTHENTICATOR:     raise GetDebugLn('Login', 'profile needs authenticator to login.');

    ERSLoginMessage.UNKNOWN:          if RSClient.IsLoggedIn() or Lobby.IsOpen() then Exit(True) else raise GetDebugLn('Login', 'Unknown login state.');
  end;
end;


procedure TRSLogin.SwitchWorld(worlds: TIntegerArray);
var
  attempt: Integer;
begin
  for attempt := 0 to 4 do
  begin
    if LoginWorldSwitcher.Switch(worlds.Random()) then
      Exit;

    if attempt < 4 then
      Sleep(Random(10000, 20000) * (1 + attempt));
  end;

  raise GetDebugLn('Login', 'Failed to switch to a valid world from the profile list after 5 attempts.');
end;


function TRSLogin.DoLogin(profile: TProfile = Default(TProfile)): Boolean;
var
  timeout: UInt64;
  switched: Boolean;
begin
  if profile = Default(TProfile) then
    profile := Profiles.Get();

  timeout := Time() + 40000;

  while not RSClient.IsLoggedIn() and not Lobby.IsOpen() do
  begin
    if Time() > timeout then
    begin
      WriteLn GetDebugLn('Login', 'Timed out trying to login.', ELogLevel.ERROR);
      Exit;
    end;

    if not switched and (profile.Worlds <> []) and
       not profile.Worlds.Contains(LoginWorldSwitcher.GetCurrent()) then
    begin
      Self.SwitchWorld(profile.Worlds);
      switched := True;
    end;

    if not Self.HandleMessage(Self.GetMessage(), profile.Username, profile.Password) then
      Exit;
    Sleep(600, 1200);
  end;

  Self.Attempts := 0;

  timeout := Time() + 15000;
  while Lobby.IsOpen() do
  begin
    if Time() > timeout then
    begin
      WriteLn GetDebugLn('Login', 'Timed out trying to handle the lobbyscreen.', ELogLevel.ERROR);
      Exit;
    end;

    if Lobby.EnterGame() then Exit(True);
  end;

  Result := RSClient.IsLoggedIn();
end;

var

  Login: TRSLogin;
