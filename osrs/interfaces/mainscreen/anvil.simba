

{$DEFINE WL_ANVIL_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TRSAnvil = record
    Title: TRSInterfaceTitle;
    Slots: TRSSlotInterface;
    Items: TRSItemInterface;
    Bounds, SlotsArea: TBox;
    SlotBoxes: TBoxArray;
    QuantityButtons: TRSButtonArray;

    Anvils: TRSObjectArray;
  end;


function TRSAnvil.GetSlotBoxes(): TBoxArray;
var
  i: Integer;
begin
  for i := 0 to High(Self.SlotBoxes) do
    if Target.HasColor($00FF00, 0, 1, Self.SlotBoxes[i]) or Target.HasColor($1F98FF, 0, 1, Self.SlotBoxes[i]) then
      Result += Self.SlotBoxes[i];
end;


procedure TRSAnvil.SetupInterface();
var
  i: Integer;
  boxes: TBoxArray;
begin
  case RSClient.Mode of
    ERSMode.FIXED: Self.Bounds := MSInterface.CreateBounds([0, 2, 0, -1], 500, 320);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := MSInterface.CreateBounds([0, -1, 0, 0], 500, 320);
  end;

  Self.Title.Setup(Self.Bounds);

  Self.SlotsArea.X1 := Self.Bounds.X1 + 4;
  Self.SlotsArea.Y1 := Self.Bounds.Y1 + 30;
  Self.SlotsArea.X2 := Self.Bounds.X2 - 50;
  Self.SlotsArea.Y2 := Self.Bounds.Y2 - 4;

  Self.SlotBoxes := TBoxArray.Create(Self.Bounds.TopLeft + [10, 36], 6, 5, 54, 54, [26, 1]);
  for i in [5, 11, 17, 23, 29] do
    Self.SlotBoxes[i] := Self.SlotBoxes[i].Offset([-15, 0]);

  Self.Slots.Setup('Anvil.Slots', Self.SlotBoxes, @Self.GetSlotBoxes);
  Self.Items.Setup('Anvil.Items', @Self.Slots, [0, 0]);

  with Self.Bounds do
    boxes := TBoxArray.Create([X2-46, Y1+36], 1, 6, 36, 36, [0,9]);

  SetLength(Self.QuantityButtons, 6);
  for i := 0 to High(boxes) do
  begin
    Self.QuantityButtons[i].Bounds := boxes[i];
    Self.QuantityButtons[i].EnabledColors := [[RSColors.TEXT_WHITE]];
  end;
end;


function TRSAnvil.IsOpen(): Boolean;
begin
  Result := MSInterface.IsOpen(ERSInterfaceType.CLASSIC) and
            Target.HasColor($00FF00, 0, 300, Self.SlotsArea);
end;


function TRSAnvil.WaitOpen(time: Integer; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;


function TRSAnvil.SetQuantity(value: Integer): Boolean;
var
  i: Integer;
  btns: TRSButtonArray;
  str: String;
begin
  if value = 1 then
    Exit(Self.QuantityButtons[0].Enable());

  for i := 1 to High(Self.QuantityButtons) do
    if Target.HasColor(RSColors.TEXT_BLACK, 0,  1, Self.QuantityButtons[i].Bounds) then
      btns += Self.QuantityButtons[i];

  if btns = [] then Exit;

  case value of
    -1, 0: str := 'All';
    5, 10: str := ToStr(value);
    else
    begin
      if Length(btns) < 2 then
        Exit;

      str := ToStr(value);
      i := High(btns);
      if OCR.RecognizeShadow(btns[i].Bounds, RSFonts.PLAIN_11, 0) = str then
        Exit(btns[i].Enabled());

      case OCR.RecognizeShadow(btns[Dec(i)].Bounds, RSFonts.PLAIN_11, 0) of
        'X': Mouse.Click(btns[i].Bounds, EMouseButton.LEFT);
        '?': ;
        else Exit;
      end;

      Exit(Chat.AnswerQuery('Enter amount:', str, 1200));
    end;
  end;

  for i := 0 to High(btns) do
    if OCR.RecognizeShadow(btns[i].Bounds, RSFonts.PLAIN_11, 0) = str then
      Exit(btns[i].Enable());
end;


function TRSAnvil.Smith(item: TRSItem; quantity: Integer = QUANTITY_ALL; keyboardProbability: Single = -1): Boolean;
var
  slot, count: Integer;
begin
  slot := Self.Items.IndexOf([item]);
  if slot = -1 then Exit;

  if not Target.HasColor($00FF00, 0, 1, Self.Slots.Box(slot)) then
    Exit;

  if not Self.SetQuantity(quantity) then Exit;

  if keyboardProbability < 0 then
    keyboardProbability := Biometrics.RandomDouble(0.5);

  count := Inventory.Items.CountEx(item);
  if RandomBoolean(keyboardProbability) and Target.HasColor($485969, 0.5, 300, Self.Slots.Box(slot)) then
    Keyboard.KeyPress(EKeyCode.SPACE)
  else
    Mouse.Click(Self.Slots.Box(slot), EMouseButton.LEFT);

  if SleepUntil(not Self.IsOpen(), 200, 4 * TICK) then
    Result := SleepUntil(Inventory.Items.CountEx(item) > count, 200, 6 * TICK);
end;



function TRSAnvil.Hover(walk: Boolean = True): Boolean;
var
  obj: TRSObject;
begin
  if Self.Anvils = [] then
    Self.Anvils := TRSObjectArray.Create(ObjectsJSON.GetByAction('Smith'));

  obj := Self.Anvils[Self.Anvils.ClosestIndex(Map.Position())];
  if walk then
    Exit(obj.WalkHover());
  Result := obj.Hover();
end;


function TRSAnvil.Open(walk: Boolean = True): Boolean; overload;
var
  obj: TRSObject;
begin
  if MSInterface.IsOpen() then
  begin
    if Self.IsOpen() then
      Exit(True);
    MSInterface.Close(True);
  end;

  if Self.Anvils = [] then
    Self.Anvils := TRSObjectArray.Create(ObjectsJSON.GetByAction('Smith'));

  obj := Self.Anvils[Self.Anvils.ClosestIndex(Map.Position())];

  if walk then
    Result := obj.WalkSelect(['nvil'])
  else
    Result := obj.Select(['nvil']);

  if not Result then
    if not MainScreen.IsUpText('Smith') or not ChooseOption.Select(['Smith']) then
      Exit;

  obj.Walker^.WaitMoving();
  Result := Self.WaitOpen(3000);
end;

var

  Anvil: TRSAnvil;
