

{$DEFINE WL_FAIRYRING_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  ERSFairyRingDial = enum(LEFT, MIDDLE, RIGHT);


  TRSFairyRing = record
    Bounds: TBox;
    Title: TRSInterfaceTitle;
    Scroll: TRSScrollBar;

    TeleportButton: TBox;

    Dials: array [ERSFairyRingDial] of String;
    DialBoxes, DialHoles, RotateLeftBoxes, RotateRightBoxes: TBoxArray;
    Item: TRSItem;
  end;


procedure TRSFairyRing.Setup();
begin
  Self.Dials[ERSFairyRingDial.LEFT] := 'ADCB';
  Self.Dials[ERSFairyRingDial.MIDDLE] := 'ILKJ';
  Self.Dials[ERSFairyRingDial.RIGHT] := 'PSRQ';
end;

function TRSFairyRing.IsOpen(): Boolean; forward;

procedure TRSFairyRing.SetupInterface();
var
  b: TBox;
begin
  case RSClient.Mode of
    ERSMode.FIXED: Self.Bounds := MSInterface.CreateBounds([0, 2, 0, 0], 500, 316);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := MSInterface.CreateBounds([0, 1, 0, 0], 500, 316);
  end;

  with Self.Bounds do
  begin
    Self.Title.Bounds := [X1+178, Y1+25, X2-178, Y1+50];
    Self.Title.CloseButton := [X2-27, Y1+1, X2-6, Y1+21];
    Self.TeleportButton := [X1+170, Y2-65, X2-170, Y2-28];
  end;

  Self.Title.TitleColor := RSFonts.BROWN;

  Self.Title.IsOpen := @Self.IsOpen;
  Self.Title.Font := @RSFonts.QUILL_8;

  with GameTab.Bounds do
    Self.Scroll.Area := [X1+3, Y1+41, X2-19, Y2-6];
  Self.Scroll.Setup();

  Self.DialBoxes := TBoxArray.Create(Self.Bounds.TopLeft + [2,80], 3, 1, 159, 155, [11,0]);
  Self.DialBoxes[2].X1 -= 2;
  Self.DialBoxes[2].X2 -= 2;

  for b in Self.DialBoxes do
  begin
    Self.DialHoles += [b.X1+58, b.Y2-55, b.X2-58, b.Y2-10];
    Self.RotateLeftBoxes += [b.X1, b.Y1, b.X2-80, b.Y2];
    Self.RotateRightBoxes += [b.X1+80, b.Y1, b.X2, b.Y2];
  end;
end;



function TRSFairyRing.IsOpen(): Boolean;
begin
  Result := Self.Title.IsTitle('Choose a combination');
end;


function TRSFairyRing.WaitOpen(time: Integer; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;



function TRSFairyRing.Close(escape: Boolean): Boolean;
begin
  Result := Self.Title.Close(escape);
end;

function TRSFairyRing.Close(escapeProbability: Single = -1): Boolean; overload;
begin
  Result := Self.Title.Close(escapeProbability);
end;



function TRSFairyRing.HandleItem(attempts: Int32 = 2): Boolean;
begin
  Result := attempts = 2; //Todo...
end;




function TRSFairyRing.Open(cuboid: TCuboid): Boolean;
begin
  if MSInterface.IsOpen() and not MSInterface.Close() then
    Exit;

  if Self.IsOpen() then
    Exit(True);

  if not Self.HandleItem() then
    Exit;

  if not MainScreen.Interact(cuboid.ShapeFill().RandomMean(), ['onfigure']) then
    Exit;

  Minimap.WaitMoving();
  Result := SleepUntil(Self.IsOpen(), RandomMode(100, 50, 1500), 2000);
end;


function TRSFairyRing.IsLetterValid(letter: Char; dial: ERSFairyRingDial): Boolean;
begin
  Result := Self.Dials[dial].Contains(letter);
end;


function TRSFairyRing.IsCodeValid(fairyCode: String): Boolean;
var
  i: Int32;
begin
  if Length(fairyCode) <> 3 then
    Exit;

  for i := 1 to Length(fairyCode) do
    if not Self.IsLetterValid(fairyCode[i], ERSFairyRingDial(i-1)) then
      Exit;

  Result := True;
end;



procedure TRSFairyRing.SpinLeft(dial: ERSFairyRingDial);
begin
  Mouse.Click(Self.RotateLeftBoxes[dial], EMouseButton.LEFT);
end;

procedure TRSFairyRing.SpinRight(dial: ERSFairyRingDial);
begin
  Mouse.Click(Self.RotateRightBoxes[dial], EMouseButton.LEFT);
end;



property TRSFairyRing.Letter(dial: ERSFairyRingDial): Char;
var
  count: integer;
begin
  count := Target.CountColor([$49153B, 6.713, EColorSpace.HSV, [1.631, 0.429, 0.942]], Self.DialHoles[dial]);

  case dial of
    ERSFairyRingDial.LEFT:
    case count of
      172: Result := 'A';
      198: Result := 'D';
      80 : Result := 'C';
      125: Result := 'B';
      else Result := 'n';
    end;

    ERSFairyRingDial.Middle:
    case count of
      52 : Result := 'L';
      98 : Result := 'K';
      66 : Result := 'J';
      65 : Result := 'I';
      else Result := 'n';
    end;

    ERSFairyRingDial.Right:
    case count of
      100 : Result := 'S';
      81 : Result := 'R';
      63 : Result := 'Q';
      85 : Result := 'P';
      else Result := 'n';
    end;
  end;
end;

property TRSFairyRing.Letter(character: Char; dial: ERSFairyRingDial): Boolean;
  function _FindChar(str: String; character: Char): Integer;
  begin
    for Result := 1 to Length(str) do
      if character = str[Result] then
        Exit;
    Result := -1;
  end;
type
  TDialSpin = record
    Moves: Integer;
    Direction: Boolean;
  end;
var
  current: Char;
  available: String;
  i, j: Integer;
  spins: TDialSPin;
begin
  if not Self.IsLetterValid(character, dial) then
    raise GetDebugLn('FairyRing', '"' + UpperCase(character) + '" is not a valid letter for fairy ring ' + ToStr(dial) + ' dial.');

  current := Self.Letter[dial];
  if current = character then
    Exit(True);

  available := Self.Dials[dial];
  i := _FindChar(available, current);
  j := _FindChar(available, character);

  case i - j of
    -3, 1: if Biometrics.RandomBoolean(0.8) then spins := [1, False] else spins := [3, True];
    -2, 2: if Biometrics.RandomBoolean(0.5) then spins := [2, False] else spins := [2, True];
    -1, 3: if Biometrics.RandomBoolean(0.8) then spins := [1, True] else spins := [3, False];
  end;

  for i := 1 to spins.Moves do
  begin
    if spins.Direction then
      Self.SpinRight(dial)
    else
      Self.SpinLeft(dial);
    Biometrics.Sleep(100, 300);
  end;

  Result := True;
end;



property TRSFairyRing.Code: String;
var
  dial: ERSFairyRingDial;
begin
  for dial := Low(ERSFairyRingDial) to High(ERSFairyRingDial) do
    Result += Self.Letter[dial];
end;

property TRSFairyRing.Code(fairyCode: String): Boolean;
var
  attempt, i: Integer;
begin
  fairyCode := fairyCode.Replace(' ', '').ToUpper();
  if not Self.IsCodeValid(fairyCode) then
    raise GetDebugLn('FairyRing', '"' + fairyCode + '" is not a valid fairy ring code.');

  for attempt := 0 to 2 do
  begin
    if fairyCode = Self.Code then
      Exit(True);

    for i := 0 to 2 do
    begin
      if not Self.Letter[fairyCode[i+1], ERSFairyRingDial(i)] then
        Continue(2);
      Biometrics.Sleep(150, 1200);
    end;

    if SleepUntil(fairyCode = Self.Code, 300, 3000) then
      Exit(True);
  end;
end;


function TRSFairyRing.ClickTeleport(): Boolean;
begin
  if not Self.IsOpen() then
    Exit;
  Mouse.Click(Self.TeleportButton, EMouseButton.LEFT);
  Result := SleepUntil(not Self.IsOpen(), 300, 3000);
end;




function TRSFairyRing.GetLogCodes(out boxes: TBoxArray): TStringArray;
var
  tpa: TPointArray;
  atpa: T2DPointArray;
  i: Int32;
  str: String;
begin
  tpa := Target.FindColor([$5F5FFF, 0.559, EColorSpace.RGB, [2.824, 0.089, 0.089]], Self.Scroll.Area);
  if tpa = [] then
    Exit;

  atpa := tpa.Cluster(9, 1.5).SortByY(True);

  boxes := atpa.BoundsArray();
  for i := 0 to High(boxes) do
  begin
    str := OCR.Recognize(boxes[i], RSFonts.PLAIN_12, [$3F3FFF, $7F7FFF], 0);
    Result += str.Replace(' ', '');

    boxes[i].X1 := Self.Scroll.Area.X1 + 21;
    boxes[i].X2 := Self.Scroll.Area.X2;
    if i = High(boxes) then
      boxes[i].Y2 := Self.Scroll.Area.Y2 - 6
    else
      boxes[i].Y2 := Min(boxes[i+1].Y1 - 8, boxes[i].Y1+37);
  end;
end;

function TRSFairyRing.GetLogCodes(): TStringArray; overload;
var
  boxes: TBoxArray;
begin
  Result := Self.GetLogCodes(boxes);
end;



function TRSFairyRing.FindLogCode(fairyCode: String; out bounds: TBox): Boolean;
  function _DoScrolling(fairyCode: String; direction: Boolean; out bounds: TBox): Boolean;
  var
    limit, i: Int32;
    boxes: TBoxArray;
  begin
    if direction then
      limit := 100;

    Mouse.Move(Self.Scroll.Area, True);
    repeat
      Mouse.Scroll(Biometrics.RandomModeInteger(4, 2, 7), direction);
      Biometrics.Sleep(400, 800);
      i := Self.GetLogCodes(boxes).IndexOf(fairyCode);
      if i > -1 then
      begin
        bounds := boxes[i];
        Exit(True);
      end;
    until not Self.Scroll.CanScroll() or (Self.Scroll.GetLevel() = limit);
  end;
var
  i, scroll: Int32;
  direction: Boolean;
  boxes: TBoxArray;
begin
  fairyCode := fairyCode.Replace(' ', '').ToUpper();
  if not Self.IsCodeValid(fairyCode) then
    raise GetDebugLn('FairyRing', '"' + fairyCode + '" is not a valid fairy ring code.');

  i := Self.GetLogCodes(boxes).IndexOf(fairyCode);
  if i > -1 then
  begin
    bounds := boxes[i];
    Exit(True);
  end;

  scroll := Self.Scroll.GetLevel();
  direction := InRange(scroll, 0, 3);
  if not direction then
    direction := not InRange(scroll, 97, 100) and Biometrics.RandomBoolean();

  if _DoScrolling(fairyCode, direction, bounds) then
    Exit(True);

  if InRange(scroll, 0, 3) or InRange(scroll, 97, 100) then
    Exit; //scrolled everything and was not found.

  Result := _DoScrolling(fairyCode, not direction, bounds);
end;

function TRSFairyRing.FindLogCode(code: String): Boolean; overload;
var
  b: TBox;
begin
  Result := Self.FindLogCode(code, b);
end;



function TRSFairyRing.ClickLogCode(fairyCode: String): Boolean;
var
  b: TBox;
begin
  fairyCode := fairyCode.Replace(' ', '').ToUpper();
  if Self.Code = fairyCode then
    Exit(True);

  if Self.FindLogCode(fairyCode, b) then
  begin
    Mouse.Click(b, EMouseButton.LEFT);
    Result := SleepUntil(Self.Code = fairyCode, 300, 5000);
  end;
end;



function TRSFairyRing.HandleInterface(fairyCode: String): Boolean;
begin
  if Biometrics.RandomBoolean(0.6) then  //use travel log or dial code...
  begin
    if not Self.ClickLogCode(fairyCode) then
      Exit;
  end
  else
  if not Self.Code[fairyCode] then
    Exit;

  Result := Self.ClickTeleport(); //TODO: Add some kind of teleport confirmation
end;



function TRSFairyRing.Teleport(fairyCode: String; cuboid: TCuboid): Boolean;
var
  contextMenuTeleport: Boolean;
begin
  if MSInterface.IsOpen() and not MSInterface.Close() then
    Exit;

  fairyCode := fairyCode.Replace(' ', '',).ToUpper();
  if fairyCode = 'ZANARIS' then
    fairyCode := 'BKS';

  if Self.IsOpen() then
    Exit(Self.HandleInterface(fairyCode));

  if fairyCode = 'BKS' then
    fairyCode := 'Zanaris';

  Mouse.Move(cuboid.ShapeFill().RandomMean());
  if not MainScreen.IsUpText('Fairy ring') then
    Exit;

  contextMenuTeleport := ChooseOption.Select(fairyCode, False, False);
  if not contextMenuTeleport then
    if not ChooseOption.Select('onfigure', False, True) then
      Exit;

  Minimap.WaitMoving();

  if contextMenuTeleport then
    Exit(True);

  if SleepUntil(Self.IsOpen(), RandomMode(100, 50, 1500), 3000) then
    Result := Self.HandleInterface(fairyCode);
end;


var

  FairyRing: TRSFairyRing;
