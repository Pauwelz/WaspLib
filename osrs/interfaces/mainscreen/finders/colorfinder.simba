

{$DEFINE WL_COLORFINDER_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TColorFinderTransformer = record
    Distance, Erode, Grow: Integer;
    LongSide, ShortSide: record
      Min, Max: Integer;
    end;
  end;


function TColorFinderTransformer.Normalize(): TColorFinderTransformer;
begin
  if Self.Distance > 0 then
    Result.Distance := MainScreen.NormalizeDistance(Self.Distance);
  if Self.Erode > 0 then
    Result.Erode := MainScreen.NormalizeDistance(Self.Erode);
  if Self.Grow > 0 then
    Result.Grow := MainScreen.NormalizeDistance(Self.Grow);

  if Self.LongSide.Min > 0 then
    Result.LongSide.Min := MainScreen.NormalizeDistance(Self.LongSide.Min);
  if Self.ShortSide.Min > 0 then
    Result.ShortSide.Min := MainScreen.NormalizeDistance(Self.ShortSide.Min);

  if Self.LongSide.Max > 0 then
    Result.LongSide.Max := MainScreen.NormalizeDistance(Self.LongSide.Max);
  if Self.ShortSide.Max > 0 then
    Result.ShortSide.Max := MainScreen.NormalizeDistance(Self.ShortSide.Max);
end;


function TColorFinderTransformer.Process(tpa: TPointArray): T2DPointArray;
var
  i, l, s: Integer;
  weights: TIntegerArray;
begin
  if tpa = [] then Exit;

  // Transform the TPA
  if Self.Grow  > 0 then tpa := tpa.Grow(Self.Grow);
  if Self.Erode > 0 then tpa := tpa.Erode(Self.Erode);

  if tpa = [] then Exit;

  Result := tpa.Cluster(Self.Distance);

  if (Self.ShortSide.Max <= 0) and (Self.LongSide.Max <= 0) then
    Exit(Result.SortBySize(True)); //sort by size

  //filter the TPA by ShortSide and LongSide
  for i := High(Result) downto 0 do
  begin
    with Result[i].MinAreaRect() do
    begin
      l := LongSideLen;
      s := ShortSideLen;
    end;

    if not InRange(s, Self.ShortSide.Min, Self.ShortSide.Max) then
    begin
      Delete(Result, i, 1);
      Continue;
    end;

    if not InRange(l, Self.LongSide.Min, Self.LongSide.Max) then
    begin
      Delete(Result, i, 1);
      Continue;
    end;

    weights += Length(Result[i]);
  end;

  if Result = [] then Exit;
  Result := Result.Sort(weights); //Sort by size making use of the prev loop.
end;


type

  TColorFinder = record
    Colors: array of TColorTolerance;
    ColorClusters: array of record
      Primary, Secondary: TColorTolerance;
      Distance: Integer;
    end;
    Transformer: TColorFinderTransformer;
  end;

function TColorFinder._FindHelper(area: TBox): TPointArray;
var
  i: Integer;
  primary, secondary: TPointArray;
begin
  for i := 0 to High(Self.Colors) do //Find TColorFinder.Colors
    Result += Target.FindColor(Self.Colors[i], area);

  for i := 0 to High(Self.ColorClusters) do //Find TColorFinder.ColorClusters
  begin
    if Self.ColorClusters[i].Distance <= 0 then
    begin
      WriteLn GetDebugLn('TColorFinder', 'Skipping cluster with 0 distance, make it higher than 0!', ELogLevel.WARN);
      Continue;
    end;

    primary := Target.FindColor(Self.ColorClusters[i].Primary, area);
    if primary = [] then Continue;

    secondary := Target.FindColor(Self.ColorClusters[i].Secondary, area);
    if secondary = [] then Continue;

    Result += primary.PointsNearby(secondary, 0, MainScreen.NormalizeDistance(Self.ColorClusters[i].Distance));
  end;
end;


function TColorFinder.Find(out atpa: T2DPointArray; areas: TBoxArray): Boolean;
var
  transformer: TColorFinderTransformer;
  area: TBox;
  tpa: TPointArray;
begin
  transformer := Self.Transformer.Normalize();

  for area in areas do
    tpa += Self._FindHelper(area);

  atpa := transformer.Process(tpa);
  Result := atpa <> [];
end;

function TColorFinder.Find(out atpa: T2DPointArray; areas: T2DPointArray; polygon: Boolean): Boolean; overload;
var
  transformer: TColorFinderTransformer;
  area: TPointArray;
  tpa, tmp: TPointArray;
begin
  transformer := Self.Transformer.Normalize();

  for area in areas do
  begin
    tmp := Self._FindHelper(area.Bounds());
    if tmp = [] then Continue;
    if polygon then
      tpa += tmp.ExtractPolygon(area)
    else
      tpa += tmp.Intersection(area);
    tmp := [];
  end;

  atpa := transformer.Process(tpa);
  Result := atpa <> [];
end;


function TColorFinder.FindEx(out atpa: T2DPointArray; out found: TBooleanArray; areas: TBoxArray): Boolean;
var
  transformer: TColorFinderTransformer;
  i: Integer;
  tpa: TPointArray;
begin
  transformer := Self.Transformer.Normalize();

  SetLength(found, Length(areas));
  for i := 0 to High(areas) do
  begin
    tpa := Self._FindHelper(areas[i]);
    if tpa = [] then Continue;
    tpa := transformer.Process(tpa).Merge();
    if tpa = [] then Continue;

    found[i] := True;
    atpa += tpa;
    tpa := [];
  end;

  Result := atpa <> [];
end;

function TColorFinder.FindEx(out atpa: T2DPointArray; out found: TBooleanArray; areas: T2DPointArray; polygon: Boolean): Boolean; overload;
var
  transformer: TColorFinderTransformer;
  i: Integer;
  tpa: TPointArray;
begin
  transformer := Self.Transformer.Normalize();

  SetLength(found, Length(areas));

  if polygon then
  begin
    for i := 0 to High(areas) do
    begin
      tpa := Self._FindHelper(areas[i].Bounds());
      if tpa = [] then Continue;

      tpa := tpa.ExtractPolygon(areas[i]);
      tpa := transformer.Process(tpa).Merge();
      if tpa = [] then Continue;

      found[i] := True;
      atpa += tpa;
      tpa := [];
    end;

    Exit(atpa <> []);
  end;

  for i := 0 to High(areas) do
  begin
    tpa := Self._FindHelper(areas[i].Bounds());
    if tpa = [] then Continue;
    tpa := tpa.Intersection(areas[i]);
    tpa := transformer.Process(tpa).Merge();
    if tpa = [] then Continue;

    found[i] := True;
    atpa += tpa;
    tpa := [];
  end;

  Result := atpa <> [];
end;


function TColorFinder.Find(out atpa: T2DPointArray): Boolean; overload;
begin
  Result := Self.Find(atpa, [MainScreen.Bounds]);
end;

