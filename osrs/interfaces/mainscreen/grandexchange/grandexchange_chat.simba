

{$DEFINE WL_GRANDEXCHANGE_CHAT_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TRSGrandExchangeChat = record
    Bounds, Header: TBox;
    Scroll: TRSScrollBar;
    Slots: TRSSlotInterface;
    Items: TRSItemInterface;
  end;

function TRSGrandExchangeChat.IsOpen(): Boolean; forward;


property TRSGrandExchangeChat.Grid: TBoxArray;
var
  b, tmp: TBox;
  tpa: TPointArray;
  boxes: TBoxArray;
  weights: TIntegerArray;
  i: Integer;
begin
  with Self.Scroll.Area do
    b := [X1+2, Y1, X2, Y2];

  boxes := b.Partition(1, 3);
  for i := 0 to High(boxes) do
  begin
    b := boxes[i];
    tpa := Target.FindColor($555555, 0, b);
    if tpa = [] then
    begin
      if i = 0 then Exit;
      Continue;
    end;
    tpa += Target.FindColor(ITEM_BORDER, 8.5, b);

    if tpa = [] then Continue;

    for tpa in tpa.Cluster(300, 1.5) do
    begin
      tmp := tpa.Bounds();
      if tmp.Height < 8 then Continue;

      tmp.X1 := b.X1;
      tmp.X2 := b.X2;
      weights += tmp.X1 + tmp.Y2 * 100;
      Result += tmp;
    end;
  end;

  Result := Result.Sort(weights, False);
end;


procedure TRSGrandExchangeChat.SetupInterface();
begin
  Self.Bounds := Chat.Bounds;

  Self.Header.X1 := Self.Bounds.X1 + 7;
  Self.Header.Y1 := Self.Bounds.Y1 + 7;
  Self.Header.X2 := Self.Bounds.X2 - 7;
  Self.Header.Y2 := Self.Bounds.Y1 + 26;

  Self.Scroll.Area.X1 := Self.Bounds.X1 + 9;
  Self.Scroll.Area.Y1 := Self.Bounds.Y1 + 29;
  Self.Scroll.Area.X2 := Self.Bounds.X2 - 25;
  Self.Scroll.Area.Y2 := Self.Bounds.Y2 - 9;

  Self.Scroll.Setup();

  Self.Slots.Setup('GrandExchangeChat.Slots', [], @Self.Grid);
  Self.Items.Setup('GrandExchangeChat.Items', @Self.Slots, [0, 1], @Self.IsOpen);
end;


function TRSGrandExchangeChat.IsOpen(): Boolean;
var
  match: Single;
begin
  if BankPin.IsOpen() then
  begin
    if not BankPin.WaitLoading(3000) then
      raise GetDebugLn('BankPin', 'GrandExchangeChat pin buttons don''t seem to have loaded in 3 seconds.');

    if not BankPin.Enter(Profiles.GetPin()) then
      raise GetDebugLn('BankPin', 'Failed to enter GrandExchangeChat pin.');
  end;

  match := OCR.Locate(Self.Header, 'What would you like to buy?', [RSFonts.BLACK], 0, RSFonts.BOLD);
  Result := match >= 0.8;
end;


function TRSGrandExchangeChat.WaitOpen(time: Integer; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;


property TRSGrandExchangeChat.SearchText: String;
begin
  Result := OCR.Recognize(Self.Header, RSFonts.BOLD, [RSFonts.DARK_BLUE], 0).Before('*');
end;

property TRSGrandExchangeChat.SearchText(search: String): Boolean;
var
  txt: String;
  i: Integer;
begin
  txt := Self.SearchText;
  search := search.ToLower();
  if txt = search then Exit(True);

  if (txt <> '') then
  begin
    for i := 1 to Length(txt) do
    begin
      if i > Length(search) then Break;
      if search[i] = txt[i] then Continue;
      Break;
    end;

    for i to Length(txt) do
    begin
      Keyboard.KeyPress(EKeyCode.BACK);
      txt.Pop;
      Sleep(50, 120);
    end;

    if Self.SearchText <> txt then
      Exit(Self.SearchText[search]);
  end;

  if txt = search then Exit(True);

  search := search.CopyRange(Length(txt)+1, Length(search));

  Keyboard.Send(search);
  Sleep(50, 120);
  Result := search = Self.SearchText;
end;


function TRSGrandExchangeChat.Find(item: TRSItem; out bounds: TBox): Boolean;
var
  str: String;
begin
  item := item.ToLower();
  for bounds in Self.Grid do
  begin
    str := OCR.RecognizeLines(bounds, RSFonts.PLAIN_12, [RSFonts.BLACK], 0).Join(' ').ToLower();
    if item = str then
      Exit(True);
  end;
end;


function TRSGrandExchangeChat.Contains(item: TRSItem): Boolean;
var
  bounds: TBox;
begin
  Result := Self.Find(item, bounds);
end;


function TRSGrandExchangeChat.Click(item: TRSItem): Boolean;
var
  bounds: TBox;
  i: Integer;
begin
  for i := 0 to 4 do
  begin
    if Self.Find(item, bounds) then
    begin
      Mouse.Click(bounds, EMouseButton.LEFT);
      Exit(SleepUntil(not Self.IsOpen(), 200, 2400));
    end;
    
    if not Self.IsOpen() then Exit;
    Sleep(50, 150);
  end;
end;



function TRSGrandExchangeChat.FindScroll(item: TRSItem): Integer;
var
  next: Integer;
  down: Boolean;
begin
  if not Self.Scroll.CanScroll() then Exit(-1);

  Result := Self.Scroll.GetLevel();
  down := (Result > 0) or RandomBoolean(0.5);

  if Self.Contains(item) then Exit;

  repeat
    if down then next := Result - 5
    else next := Result + 5;

    Result := Self.Scroll.SetLevel(next);
    if Self.Contains(item) then Exit;

    if not Self.IsOpen() then Exit(-1); //failsafe
  until not InRange(Result, 1, 99);

  down := not down;
  repeat
    if down then next := Result - 5
    else next := Result + 5;

    Result := Self.Scroll.SetLevel(next);
    if Self.Contains(item) then Exit;

    if not Self.IsOpen() then Exit(-1);
  until not InRange(Result, 1, 99);

  Result := -1;
end;


function TRSGrandExchangeChat.ScrollTo(item: TRSItem): Boolean;
begin
  Result := Self.FindScroll(item) > -1;
end;


var

  GrandExchangeChat: TRSGrandExchangeChat;
