

{$DEFINE WL_MAINSCREEN_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TRSMainScreen = record
    Bounds: TBox;
    Center: TPoint;
    TopLeft, TopRight, BottomRight, BottomLeft: TPoint;

    UpTextImageBuffer: TImage;
    UptextBounds, ServerMsgBounds: TBox;
    UptextOCR: TPixelOCR;

    HighestPitch: Boolean;

    Mask: TImage;
  end;


procedure TRSMainScreen.SetupInterface();
begin
  case RSClient.Mode of
    ERSMode.FIXED:
      with RSClient.Bounds do
        Self.Bounds := TBox.Create(X1+4,4,X1+515,337);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := RSClient.Bounds;
  end;

  Self.Center := Self.Bounds.Center;

  Self.TopLeft     := Self.Bounds.TopLeft;
  Self.TopRight    := Self.Bounds.TopRight;
  Self.BottomRight := Self.Bounds.BottomRight;
  Self.BottomLeft  := Self.Bounds.BottomLeft;

  if RSClient.Client = ERSClient.OFFICIAL then
  begin
    Self.UptextBounds.X1 := Self.Bounds.X1;
    Self.UptextBounds.Y1 := Self.Bounds.Y1 + 1;
    Self.UptextBounds.X2 := Self.Bounds.X1 + 497;
    Self.UptextBounds.Y2 := Self.Bounds.Y1 + 19;
  end
  else
  begin
    Self.UptextBounds.X1 := Self.Bounds.X1 + 3;
    Self.UptextBounds.Y1 := Self.Bounds.Y1 + 3;
    Self.UptextBounds.X2 := Self.Bounds.X1 + 500;
    Self.UptextBounds.Y2 := Self.Bounds.Y1 + 21;
  end;

  Self.ServerMsgBounds.X1 := Self.Bounds.X1 + 2;
  Self.ServerMsgBounds.Y1 := Self.Bounds.Y1 + 2;
  Self.ServerMsgBounds.X2 := Self.ServerMsgBounds.X1 + 129;
  Self.ServerMsgBounds.Y2 := Self.ServerMsgBounds.Y1 + 20;

  Self.Mask := new TImage(Target.Width+1, Target.Height+1);
  Self.Mask.Fill($FFFFFF);
  Self.Mask.DrawColor := $0;
  Self.Mask.DrawBoxFilled(Self.Bounds);
  Self.Mask.SetAlphas(TPointArray.CreateFromBox(Self.Bounds, True), $0);
  Self.Mask.DrawColor := $FFFFFF;
  Self.Mask.DrawAlpha := $FF;
end;





property TRSMainScreen.UpText: String;
var
  img: TImage;
begin
  img := Target.GetImage(Self.UptextBounds);
  Result := Self.UptextOCR.Recognize(img, RSFonts.BOLD_SHADOW, [0,0]);
  {$IFDEF WL_DEBUG_UPTEXT}
  WriteLn GetDebugLn('MainScreen', 'UpText: ' + Result);
  {$ENDIF}
end;



function TRSMainScreen._IsUpText(strings: TStringArray; caseSensitive: Boolean; similarity: Single): Boolean;
var
  upText, str: String;
  i: Integer;
  match: Double;
begin
  if caseSensitive then
    upText := Self.UpText
  else
    upText := LowerCase(Self.UpText);

  for str in strings do
  begin
    if Length(upText) = Length(str) then
    begin
      match := str.Similarity(upText);
      Result := match > similarity;
    end
    else
    begin
      //shift string until best match is found.
      for i := 1 to Length(upText)-Length(str) do
      begin
        match := str.Similarity(Copy(upText, i, Length(str)));
        Result := match > similarity;
        if Result then
          Break;
      end;
    end;

    if Result then
    begin
      {$IFDEF WL_DEBUG_UPTEXT}
      WriteLn GetDebugLn('MainScreen', 'IsUpText Similarity: ' + ToStr(match));
      {$ENDIF}
      Break;
    end;
  end;
end;



function TRSMainScreen.IsUpText(strings: TStringArray; caseSensitive: Boolean = True; similarity: Single = 0.85; time: Integer = -1): Boolean;
var
  timeout: TCountDown;
  strs: TStringArray;
  str: String;
begin
  if time = -1 then
    time := Round(RandomMode(100, 85, 250));

  timeout.Start(time);

  if caseSensitive then
    strs := Copy(strings)
  else
  begin
    for str in strings do
      strs += LowerCase(str);
  end;

  repeat
    if Self._IsUpText(strings, caseSensitive, similarity) then
    begin
      Sleep(50);
      if Self._IsUpText(strings, caseSensitive, similarity) then
        Exit(True);
    end;

    Sleep(25);
  until timeout.IsFinished;
end;

function TRSMainScreen.IsUpText(text: String; caseSensitive: Boolean = True; similarity: Single = 0.85; time: Integer = -1): Boolean; overload;
begin
  Result := Self.IsUpText([text], caseSensitive, similarity, time);
end;





property TRSMainScreen.ServerMessage: String;
var
  black: TPointArray;
begin
  black := Target.FindColor($0, 0, Self.ServerMsgBounds);
  if Length(black) < 500 then Exit;
  Result := OCR.Recognize(black.Bounds(), RSFonts.PLAIN_12, [$FFFFFF], 0);
end;


function TRSMainScreen.IsServerMessage(text: String; caseSensitive: Boolean = True; similarity: Single = 0.85): Boolean; overload;
var
  msg: String;
begin
  if caseSensitive then
    msg := Self.ServerMessage
  else
  begin
    text := LowerCase(text);
    msg := LowerCase(Self.ServerMessage);
  end;

  if msg = '' then Exit;

  msg := Copy(msg, 1, Length(text));
  Result := text.Similarity(msg) >= similarity;
end;



procedure TRSMainScreen.SetHighestPitch();
var
  i, area: Integer;
begin
  area := Self.Bounds.Area * 100;
  Keyboard.KeyDown(EKeyCode.UP);
  Sleep(30);
  for i := 1 to 10 do // 2500ms timeout
    if (Target.GetPixelDifference(250, Self.Bounds).Length / area) < 10 then // less than 10% of the screen changed in 250ms
      Break;
  Keyboard.KeyUp(EKeyCode.UP);
  Self.HighestPitch := True;
end;

{$R-}
function TRSMainScreen._IsVisible(pt: TPoint; tabNone, xpbarClosed, chatClose: Boolean): Boolean;
var
  color: TColor;
begin
  if not Self.Bounds.Contains(pt) then
    Exit;
  color := Self.Mask.Pixel[pt.X, pt.Y];

  case color of
    $0: Exit(True);
    $00FFFF: Exit(tabNone);
    $00FF00: Exit(xpbarClosed);
    $0000FF: Exit(chatClose);
    $FFFFFF: Exit;
    else Exit;
  end;
end;


function TRSMainScreen.IsVisible(pt: TPoint): Boolean;
begin
  Result := pt <> pt; //overriden, check overrides.
end;

function TRSMainScreen.AnyVisible(tpa: TPointArray): Boolean;
begin
  Result := tpa <> tpa; //overriden, check overrides.
end;

function TRSMainScreen.AllVisible(tpa: TPointArray): Boolean;
begin
  Result := tpa <> tpa; //overriden, check overrides.
end;



function TRSMainScreen.Filter(tpa: TPointArray): TPointArray;
begin
  Result := tpa.Copy(); //overriden, check overrides.
end;
{$R+}

function TRSMainScreen._RedClicked(area: TBox): Boolean;
begin
  Result := Target.HasColor($0000FF, 0, 1, area) or Target.HasColor($0401C8, 0, 1, area);
end;


function TRSMainScreen.RedClicked(): Boolean;
var
  area: TBox;
begin
  area := TBox.Create(Target.MouseXY, 10, 10).Clip(Self.Bounds);
  Result := Self._RedClicked(area);
end;


function TRSMainScreen.WaitRedClick(time: Integer = 250): Boolean;
var
  area: TBox;
begin
  area := TBox.Create(Target.MouseXY, 10, 10).Clip(Self.Bounds);
  Result := SleepUntil(Self._RedClicked(area), 50, time);
end;

function TRSMainScreen._YellowClicked(area: TBox): Boolean;
begin
  Result := Target.HasColor(65535, 0, 1, area);
end;


function TRSMainScreen.YellowClicked(): Boolean;
var
  area: TBox;
begin
  area := TBox.Create(Target.MouseXY, 10, 10).Clip(Self.Bounds);
  Result := Self._YellowClicked(area);
end;


function TRSMainScreen.WaitYellowClick(time: Integer = 250): Boolean;
var
  area: TBox;
begin
  area := TBox.Create(Target.MouseXY, 10, 10).Clip(Self.Bounds);
  Result := SleepUntil(Self._YellowClicked(area), 50, time);
end;


function TRSMainScreen.Interact(strings: TStringArray): Boolean;
begin
  if Self.IsUpText(strings) then
  begin
    Mouse.Click(EMouseButton.LEFT);
    if Self.RedClicked() then
      Exit(True);
  end;

  if ChooseOption.Select(strings) then
    Exit(Self.RedClicked());
end;

function TRSMainScreen.Interact(pt: TPoint; strings: TStringArray): Boolean; overload;
begin
  Mouse.Move(pt);
  Result := Self.Interact(strings);
end;

var

  MainScreen: TRSMainScreen;


function TBiometrics.YellowClick(button: EMouseButton; clicks: UInt32 = 3): Boolean;
var
  i: Integer;
begin
  Mouse.Click(button);
  Result := MainScreen.YellowClicked();

  if Random() > Self.RandomModeDouble(0.08, 0.05, 0.1) then
    Exit;

  for i := 1 to Self.RandomModeInteger(clicks div 2, 1, clicks) do
  begin
    Mouse.Click(Mouse.Position.Random(5), button);
    Sleep(0, 100, ERandomDir.LEFT);
  end;

  Result := MainScreen.YellowClicked() and not MainScreen.RedClicked();
end;


function TBiometrics.RedClick(button: EMouseButton; clicks: UInt32 = 3): Boolean;
var
  i: Integer;
begin
  Mouse.Click(button);
  Result := MainScreen.RedClicked();

  if Random() > Self.RandomModeDouble(0.08, 0.05, 0.1) then
    Exit;

  for i := 1 to Self.RandomModeInteger(clicks div 2, 1, clicks) do
  begin
    Mouse.Click(Mouse.Position.Random(5), button);
    Sleep(0, 100, ERandomDir.LEFT);
  end;

  Result := MainScreen.RedClicked() and not MainScreen.YellowClicked();
end;
