

{$DEFINE WL_SHOP_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  ERSShopQuantity = enum(ONE, FIVE, TEN, FIFTY);

  TRSShop = record
    Title: TRSInterfaceTitle;
    Slots: TRSSlotInterface;
    Items: TRSItemInterface;

    Bounds, SlotsArea, _IsOpenHelper: TBox;
    SlotBoxes: TBoxArray;

    QuantityButtons: array [ERSShopQuantity] of TRSButton;
    ValueButton: TRSButton;

    Shops: TRSObjectArray;
    Merchants: TRSEntityArray;
  end;


function TRSShop.FindItemBoundaries(): TBoxArray;
var
  tpa, final: TPointArray;
  atpa: T2DPointArray;
  b: TBox;
  stack: ERSStack;
begin
  final := Target.FindColor(ITEM_BORDER, 1, Self.SlotsArea);
  if final = [] then Exit;

  for stack := Low(ERSStack) to High(ERSStack) do
  begin
    tpa := Target.FindColor(stack.Color, 0, Self.SlotsArea);
    if tpa <> [] then
      final += tpa;
  end;

  atpa := final.Cluster(200, 3);

  for tpa in atpa do
  begin
    b := tpa.Bounds();
    if b.Height <= 5 then Continue;

    Result += TBoxArray.Create([Self.SlotsArea.X1, b.Y1], 8, 1, 31, Min(Self.SlotsArea.Y2-b.Y1, 31), [16, 1]);
  end;
end;

function TRSShop.IsOpen(): Boolean; forward;


procedure TRSShop.SetupInterface();
var
  i: Integer;
  boxes: TBoxArray;
  quantity: ERSShopQuantity;
begin
  case RSClient.Mode of
    ERSMode.FIXED: Self.Bounds := MSInterface.CreateBounds([0, 3, 1, 3], 488, 300);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := MSInterface.CreateBounds([-1, 1, 0, 4], 488, 300);
  end;

  Self.Title.Setup(Self.Bounds);

  with Self.Bounds do
  begin
    Self._IsOpenHelper := TBox.Create(X1 + 30, Y2 - 35, X1 + 100, Y2 - 12);
    Self.ValueButton.Bounds := TBox.Create(X1 + 110, Y2 - 37, X1 + 139, Y2 - 8);
  end;
  Self.ValueButton.EnabledColors := [[$0F1043, 0], [$23269F, 0.227]];

  Self.SlotBoxes := TBoxArray.Create(Self.Bounds.TopLeft.Offset(61, 40), 8, 5, 35, 32, [12,15]);
  Self.SlotsArea := Self.SlotBoxes.Merge();
  //Self.SlotBoxes := TBoxArray.Create(Self.SlotsArea.TopLeft, 4, 2, 47, 47, [4, 4]);
  Self.Slots.Setup('Shop.Slots', Self.SlotBoxes, @Self.FindItemBoundaries);
  Self.Items.Setup('Shop.Items', @Self.Slots, [0, 1], @Self.IsOpen);

  for i := 0 to 3 do
    begin
      Self.QuantityButtons[i].EnabledColors := [[$0F1043, 0], [$23269F, 0.227]];
    end;

  with Self.Bounds do
    boxes := TBoxArray.Create([X2-196, Y2-37], 4, 1, 29, 29, [11,0]); // This is the whole button
    //boxes := TBoxArray.Create([X2-192, Y2-33], 4, 1, 21, 21, [19,0]); // This is just for the inside of the button;

  for quantity := Low(ERSShopQuantity) to High(ERSShopQuantity) do
    begin
      Self.QuantityButtons[quantity].Bounds := boxes[Ord(quantity)];
    end;
end;


function TRSShop.IsOpen(): Boolean;
begin
  Result := OCR.Recognize(Self._IsOpenHelper, RSFonts.PLAIN_12, [RSFonts.ORANGE], 0).ContainsAny(['Value','check'], True);
end;


function TRSShop.WaitOpen(time: Integer = 600; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;


function TRSShop.Close(escape: Boolean): Boolean;
begin
  Result := Self.Title.Close(escape);
end;

function TRSShop.Close(escapeProbability: Single = -1): Boolean; overload;
begin
  Result := Self.Title.Close(escapeProbability);
end;


function TRSShop.Buy(item: TRSItem; quantity: ERSShopQuantity = ERSShopQuantity.ONE): Boolean;
begin
  Result := False;
  if not Self.IsOpen() then Exit;
  if not Self.Items.Contains(item) then Exit;


  if not Self.QuantityButtons[quantity].Enabled then
    Self.SetQuantity(quantity);

  case quantity of
    ERSShopQuantity.ONE: Self.Items.Interact(item, 'Buy 1');
    ERSShopQuantity.FIVE: Self.Items.Interact(item, 'Buy 5');
    ERSShopQuantity.TEN: Self.Items.Interact(item, 'Buy 10');
    ERSShopQuantity.FIFTY: Self.Items.Interact(item, 'Buy 50');
  end;


  // TODO Maybe add Count tracking to see if sale was successful
  Sleep(200, 300);
  Result := True;
end;


function TRSShop.Sell(item: TRSItem; quantity: ERSShopQuantity = ERSShopQuantity.ONE): Boolean;
begin
  Result := False;
  if not Self.IsOpen() then Exit;
  if not Inventory.Items.Contains(item) then Exit;

  if not Self.QuantityButtons[quantity].Enabled then
    Self.SetQuantity(quantity);

  case quantity of
    ERSShopQuantity.ONE: Inventory.Items.Interact(item, 'Sell 1');
    ERSShopQuantity.FIVE: Inventory.Items.Interact(item, 'Sell 5');
    ERSShopQuantity.TEN: Inventory.Items.Interact(item, 'Sell 10');
    ERSShopQuantity.FIFTY: Inventory.Items.Interact(item, 'Sell 50');
  end;

  // TODO Maybe add Count tracking to see if sale was successful
  Sleep(200, 300);
  Result := True;
end;


function TRSShop.GetPrice(item: TRSItem): Integer;
begin
  if not Self.IsOpen() then Exit;
  if not Self.Items.Contains(item) then Exit;

  if not Self.ValueButton.Enabled then
    Self.ValueButton.Enable();

  Sleep(600, 800);

  if Self.Items.Interact(item, 'Value') then
  begin
    Biometrics.Sleep(100, 300);
    // TODO: Implement price reading from chat or interface
    Result := 0;
  end;
end;


function TRSShop.SetQuantity(quantity: ERSShopQuantity): Boolean;
begin
  if Self.QuantityButtons[quantity].Enabled() then Exit(True);
  Result := Self.QuantityButtons[quantity].Enable();
  if Result then Sleep(600, 800);
end;

procedure TRSShop._SetupMapObjects();
begin
  Self.Shops     := TRSObjectArray.Create(ObjectsJSON.GetByAction('Buy-food'));
  Self.Merchants := TRSEntityArray.Create(NPCsJSON.GetByAction('Trade'));
end;



function TRSShop.Hover(obj: TRSObject; walk: Boolean = True): Boolean;
begin
  if walk then
    Exit(obj.WalkHover());
  Result := obj.Hover();
end;

function TRSShop.Hover(npc: TRSEntity; walk: Boolean = True): Boolean; overload;
begin
  if walk then
    Exit(npc.WalkHover());
  Result := npc.Hover();
end;


function TRSShop.Open(obj: TRSObject; walk: Boolean = True): Boolean;
begin
  if walk then
    Result := obj.WalkInteract(['Trade'])
  else
    Result := obj.Interact(['Trade']);

  if not Result then
    if not MainScreen.IsUpText('Trade') or not ChooseOption.Select(['Trade']) then
      Exit;

  obj.Walker^.WaitMoving();
  Result := Self.WaitOpen(3000);
end;

function TRSShop.Open(npc: TRSEntity; walk: Boolean = True): Boolean; overload;
begin
  if walk then
    Result := npc.WalkInteract(['Trade', 'Trade'])
  else
    Result := npc.Interact(['Trade']);

  if not Result and not MainScreen.Interact(['Trade']) then
    Exit;

  npc.Walker^.WaitMoving();
  Result := Self.WaitOpen(3000);
end;

procedure TRSShop.Draw(img: TImage);
var
  i: Integer;
begin
  if not Self.IsOpen() then Exit;

  img.DrawColor := $00FFFF;
  img.DrawBox(Self.Bounds);

  img.DrawColor := $0000FF;
  img.DrawBox(Self.SlotsArea);
  img.DrawBox(Self._IsOpenHelper);

  img.DrawColor := Colors.AQUA;
  img.DrawBox(Self.ValueButton.Bounds);

  img.DrawColor := $FFFFFF;
  img.DrawBoxArray(Self.SlotBoxes, False);

  img.DrawColor := $00FF00;
  img.DrawBoxArray(Self.FindItemBoundaries(), False);

  for i := 0 to High(Self.QuantityButtons) do
    Self.QuantityButtons[i].Draw(img);
end;

procedure TRSShop.ShowOnTarget();
var
  img: TImage;
begin
  img := Target.GetImage();
  Self.Draw(img);
  img.Show();
end;

var

  Shop: TRSShop;
