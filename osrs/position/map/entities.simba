

{$DEFINE WL_RSENTITIES_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  ENPCData = enum(ID, NAME, LEVEL, CATEGORY, MINIMAPDOT, ACTIONS, SIZE, COORDINATES, COLORS);


  TRSEntity = record
    UpText: TStringArray;
    Size: TVector3;
    Model: TModel;
    Coordinates: TPointArray;
    Filter: TRSDotFilterArray;
    Finder: TColorFinder;
    Track: Boolean;
    MinimapDots: ERSMinimapDots;
    LastCoordinate: TPoint;
    Walker: PRSWalker;
  end;


  TRSEntityArray = array of TRSEntity;


function TRSEntity.Create(walker: PRSWalker; size: TVector3; radius: Integer; coordinates: TPointArray; uptext: TStringArray = []; dots: ERSMinimapDots = []): TRSEntity; static;
var
  pt: TPoint;
begin
  Result.Coordinates := coordinates;
  Result.Size := size;

  if dots <> [] then
    Result.MinimapDots := dots;
  if uptext <> [] then
    Result.UpText := uptext;

  Result.Finder := Default(TColorFinder);
  Result.Walker := walker;

  for pt in coordinates do
    Result.Filter += TRSDotFilter.Create([], TCircle.Create(pt.X, pt.Y, radius), True);
end;

function TRSEntity.Create(json: TJSONObject): TRSEntity; static; overload;
var
  i, j, l: Integer;
  unique: array of TColorArray;
  color: TColor;
  best: TBestColor;
  coord: TJSONArray;
begin
  if json.Typ <> EJSONType.OBJ then
    raise GetDebugLn('TRSEntity', 'JSON Object expected, got ' + ToStr(json.Typ) + '.');

  with json.Item[Ord(ENPCData.NAME)] do
    if AsString <> 'null' then
      Result.UpText := [AsString];

  if json.Item[Ord(ENPCData.MINIMAPDOT)].AsBool then
    Result.MinimapDots := [ERSMinimapDot.NPC];

  with json.Item[Ord(ENPCData.SIZE)] do
  begin
    Result.Size.X := Item[0].AsInt * 0.8;
    Result.Size.Y := Item[1].AsInt * 0.8;
    Result.Size.Z := Item[2].AsInt / 40;
  end;

  if Abs(Result.Size.Z) < 0.05 then
    Result.Size.Z := 3.0;

  with json.Item[Ord(ENPCData.COORDINATES)] do
    for i := 0 to Count-1 do
    begin
      coord := Item[i];
      Result.Coordinates += [coord.Item[0].AsInt, coord.Item[1].AsInt];
      Result.Filter += TRSDotFilter.Create([], TCircle.Create(coord.Item[0].AsInt, coord.Item[1].AsInt, 40), True);
    end;

  with json.Item[Ord(ENPCData.COLORS)] do
    for i := 0 to Count-1 do
    begin
      color := Item[i].AsInt;

      for j := 0 to High(unique) do
      begin
        for l := 0 to High(unique[j]) do
          if ColorDistance(color, unique[j, l], EColorSpace.HSL, [1.5, 1.5, 1.5]) < 15 then
          begin
            unique[j] += color;
            Continue(3);
          end;
      end;

      unique += [color];
    end;

  for i := 0 to High(unique) do
  begin
    best := GetBestColor(EColorSpace.HSL, unique[i]);
    Result.Finder.Colors += [best.Color, best.Tolerance*1.5, EColorSpace.HSL, [best.Mods[0]*1.5, best.Mods[1]*1.5, best.Mods[2]*1.5]];
  end;

  Result.Walker := @Map.Walker;
end;


function TRSEntityArray.Create(json: TJSONArray): TRSEntityArray; static;
var
  i: Integer;
begin
  if json.Typ <> EJSONType.ARR then
    raise GetDebugLn('TRSEntity', 'JSON Array expected, got ' + ToStr(json.Typ) + '.');

  SetLength(Result, json.Count);
  for i := 0 to High(Result) do
    Result[i] := TRSEntity.Create(json.Item[i]);
end;



function TRSEntity._GetBounds(me: TPoint; vector: TVector2; size: TVector3; height, radians: Single): TPolygon;
var
  corners: TVector3Array;
  pt: TPoint;
begin
  pt := me + vector.ToPoint() - Minimap.Center;
  if Self.Model <> nil then
    Exit(Self.Model.GetArea(Self.Model.Project(vector.ToVec3(Self.Walker^.Height(pt, False) - height), 0, radians)));


  size.X := size.X*2;
  size.Y := size.Y*2;

  corners := [
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height],
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height+size.Z],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height+size.Z],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height+size.Z],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height+size.Z]
  ];

  Result := Projection.Run(corners, radians).ConvexHull();
end;


function TRSEntity.GetBoundsArray(me: TPoint; out coordinates: TPointArray; radians: Single = $FFFF): TPolygonArray;
var
  weights: TDoubleArray;
  meLocal, pt: TPoint;
  i: Integer;
  h, dist: Double;
  vector: TVector2;
  dots: TPointArray;
begin
  coordinates := [];
  if radians = $FFFF then
    radians := Minimap.CompassRadians;

  meLocal := Self.Walker^.GetLocal(me);

  h := Self.Walker^.Height(meLocal - [1,3], False) + Self.Walker^.Height(meLocal + [3,-3], False) +
       Self.Walker^.Height(meLocal + [3,1], False) + Self.Walker^.Height(meLocal - [1,1], False);
  h := h/4;

  if Self.Filter <> [] then
  begin
    dots := Minimap.GetFilteredDotArray(Self.MinimapDots, Self.Walker^.FiltersToMM(me, Self.Filter, radians));
    if dots = [] then
      Exit;

    dots := dots.SortFrom(Minimap.Center);
    for i := 0 to High(dots) do
    begin
      pt := Self.Walker^.MM2Map(me, dots[i], radians);
      coordinates += pt;

      vector := Self.Walker^.Point2MMVec(me, pt, radians);
      vector := vector.Rotate(-radians, Minimap.Center);
      Result += Self._GetBounds(meLocal, vector, Self.Size, h, radians);
    end;
    Exit;
  end;

  for i := 0 to High(Self.Coordinates) do
  begin
    pt := Self.Coordinates[i];
    dist := me.DistanceTo(pt);
    if dist > 85 then
      Continue;

    weights += dist;
    coordinates += pt;

    vector := Self.Walker^.Point2MMVec(me, pt, radians);
    vector := vector.Rotate(-radians, Minimap.Center);
    Result += Self._GetBounds(meLocal, vector, Self.Size, h, radians);
  end;

  if Result <> [] then
  begin
    Sort(Result, weights, True);
    coordinates.Sort(weights, True);
  end;
end;


function TRSEntity.FindOnMainScreen(out coordinates: TPointArray; boundsArray: TPolygonArray): T2DPointArray;
var
  i: Integer;
  found: TBooleanArray;
begin
  if Self.Finder <> Default(TColorFinder) then
  begin
    Self.Finder.FindEx(Result, found, boundsArray, Self.Model = nil);

    for i := High(found) downto 0 do
      if not found[i] then
        Delete(coordinates, i, 1);

    Exit;
  end;

  if Self.Model <> nil then
    Exit(boundsArray);

  for i := 0 to High(boundsArray) do
    Result += TPointArray(boundsArray[i]).Connect().ShapeFill();
end;


function TRSEntity.FindEx(me: TPoint; out boundsArray: TPolygonArray; out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
begin
  boundsArray := Self.GetBoundsArray(me, coordinates);
  if boundsArray = [] then Exit;
  atpa := Self.FindOnMainScreen(coordinates, boundsArray);

  Result := atpa <> [];
end;



function TRSEntity.Find(out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
var
  boundsArray: TPolygonArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), boundsArray, coordinates, atpa);
end;

function TRSEntity.Find(out atpa: T2DPointArray): Boolean; overload;
var
  coordinates: TPointArray;
  boundsArray: TPolygonArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), boundsArray, coordinates, atpa);
end;


function TRSEntity.FindFrom(position: TPoint; out atpa: T2DPointArray): Boolean;
var
  boundsArray: TPolygonArray;
  coordinates: TPointArray;
begin
  Result := Self.FindEx(position, boundsArray, coordinates, atpa);
end;


function TRSEntity._UpTextCheck(out shouldExit: Boolean; action: TStringArray): Boolean;
var
  text: String;
begin
  shouldExit := True;

  if (RSClient.Mode = ERSMode.FIXED) and MSInterface.IsOpen() then
    Exit;

  if Self.UpText <> [] then
    Self.Walker^.TargetUpText := Copy(Self.UpText);

  text := MainScreen.UpText;

  if text.Contains('>') and not action.Contains(['>']) then
  begin
    ChooseOption.Close();
    Exit;
  end;

  if (Self.UpText <> []) and text.ContainsAny(Self.UpText) then
    Exit(True);

  shouldExit := False;
end;


function TRSEntity._HoverHelper(action: TStringArray; attempts: Integer): Boolean;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
begin
  Result := Self._UpTextCheck(shouldExit, action);
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    if attempt <> (attempts - 1) then
      Continue;

    Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;


function TRSEntity._WalkHoverHelper(action: TStringArray; attempts: Integer): Boolean;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
  path: TGraphNodeArray;
  me, closest: TPoint;
begin
  Result := Self._UpTextCheck(shouldExit, action) or Self.Walker^.RedClicked;
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    me := Self.Walker^.Position();
    closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

    if path = [] then
    begin
      path := Self.Walker^.WebGraph^.PathToNear(me, closest, 0.33);
      if path = [] then
        raise GetDebugLn('TRSEntity', 'Can''t path to object.');
    end;

    if me.DistanceTo(closest) > 50 then
    begin
      Self.Walker^.WebWalkEx(me, closest, 30, 0.15);
      Continue;
    end;

    if attempt <> (attempts - 1) then Continue;

    if me.DistanceTo(closest) > 25 then
    begin
      Self.Walker^.WebWalkEx(me, closest, 25, 0.15);
      Continue;
    end;

    Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;


function TRSEntity._PreHoverHelper(me: TPoint; attempts: Integer = 2): Boolean;
var
  attempt: Integer;
  atpa: T2DPointArray;
begin
  for attempt := 0 to attempts do
  begin
    if not Self.FindFrom(me, atpa) then Continue;
    Mouse.Move(atpa.Random().Random());
    Exit(True);
  end;
end;



function TRSEntity._ClickHelper(leftClick: Boolean): Boolean;
begin
  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Select(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
    Exit;
  end;

  if leftClick and Biometrics.RedClick(EMouseButton.LEFT, 2) then
    Exit(True);

  Result := not leftClick and (Self.UpText <> []) and ChooseOption.Select(Self.UpText);
end;


function TRSEntity._SelectHelper(action: TStringArray): Boolean;
begin
  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() and ChooseOption.Select(action) then
    Exit(True);

  if MainScreen.IsUpText(action) then
    Exit(Biometrics.RedClick(EMouseButton.LEFT, 2));

  Result := ChooseOption.Select(action);
end;



function TRSEntity.Hover(action: TStringArray = []; attempts: Integer = 2): Boolean;
begin
  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Find(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  //TODO:
  //if not Self.Walker^.MakePointVisible(Self.Coordinates) then Exit;

  Result := Self._HoverHelper(action, attempts);
end;


function TRSEntity.WalkHover(action: TStringArray = []; attempts: Integer = 2): Boolean;
var
  me, closest: TPoint;
  path: TGraphNodeArray;
  hasPath: Boolean;
begin
  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Find(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  me :=  Self.Walker^.Position();
  closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

  //if the point is not reachable with the webgraph (like a banker behind a booth) then pick nearest node as target
  if path = [] then
  begin
    path := Self.Walker^.WebGraph^.PathToNear(me, closest, 0.33);
    if path = [] then
      raise GetDebugLn('TRSEntity', 'Can''t path to object.');
    hasPath := True;
  end;

  Self.Walker^.TargetUpText := Copy(Self.UpText);
  Self.Walker^.ActionUpText := action;

  try
  // check if doors need to be passed to reach target
    if hasPath or Self.Walker^.WebGraph^.WalkableClusters.InSameTPA(me, closest) then
    begin
      if not Self.Walker^.MakePointVisible(closest) and not Self.Walker^.WebWalkEx(me, closest, 30, 0.15) then
        Exit;
    end
    else
    if not Self.Walker^.WebWalk(closest, 30, 0.15) then
      Exit;

    Result := Self._WalkHoverHelper(action, attempts);
  finally
    Self.Walker^.TargetUpText := [];
    Self.Walker^.ActionUpText := [];
  end;
end;



function TRSEntity.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  Result := Self.Hover([], attempts) and Self._ClickHelper(leftClick);
end;


function TRSEntity.Interact(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  Result := Self.Hover(action, attempts) and Self._SelectHelper(action);
end;


function TRSEntity.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  Result := Self.WalkHover([], attempts) and Self._ClickHelper(leftClick);
end;


function TRSEntity.WalkInteract(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  Result := Self.WalkHover(action, attempts) and Self._SelectHelper(action);
end;


function TRSEntity.DistanceTo(pt: TPoint): Double;
var
  dist: Double;
  i: Integer;
begin
  Result := $FFFFFF;
  for i := 0 to High(Self.Coordinates) do
  begin
    dist := Self.Coordinates[i].DistanceTo(pt);
    if dist < Result then
      Result := dist;
  end;
end;

function TRSEntityArray.ClosestIndex(pt: TPoint): Integer;
var
  closest, dist: Double;
  i, j: Integer;
begin
  closest := $FFFFFF;
  for i := 0 to High(Self) do
    for j := 0 to High(Self[i].Coordinates) do
    begin
      dist := Self[i].Coordinates[j].DistanceTo(pt);
      if dist >= closest then Continue;

      closest := dist;
      Result := i;
    end;
end;


procedure TImage.DrawEntity(entity: TRSEntity);
var
  me: TPoint;
  atpa: T2DPointArray;
  boundsArray: TPolygonArray;
  i: Integer;
  filters: TRSDotFilterArray;
  filter: TRSDotFilter;
  coordinates: TPointArray;
begin
  me := entity.Walker^.Position();
  filters := entity.Walker^.FiltersToMM(me, entity.Filter, Minimap.CompassRadians);

  for filter in filters do
  begin
    if not Minimap.Bounds.Overlap(filter.Poly.Bounds()) and
       not Minimap.Bounds.Overlap(filter.Circle.Bounds) then Continue;

    if filter.Inside then
      Self.DrawColor := $00FF00
    else
      Self.DrawColor := $0000FF;

    Self.DrawPolygon(filter.Poly);
    Self.DrawCircle(filter.Circle);
  end;

  if entity.FindEx(me, boundsArray, coordinates, atpa) then
  begin
    Self.DrawColor := TColor.Random();
    Self.DrawATPA(atpa);
  end;

  Self.DrawColor := $FFFFF;
  for i := 0 to High(boundsArray) do
    Self.DrawTPA(boundsArray[i].Connect());
end;


procedure ShowOnTarget(entity: TRSEntity); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  img.DrawEntity(entity);
  img.Show();
end;



procedure ShowOnTarget(entities: TRSEntityArray); overload;
var
  img: TImage;
  i: Integer;
begin
  img := Target.GetImage();
  for i := 0 to High(entities) do
    img.DrawEntity(entities[i]);
  img.Show();
end;


function ToString(constref entity: TRSEntity): String; override;
begin
  Result := '[' + ToString(entity.UpText) + ', ' +
                  ToString(entity.Size) + ', ' +
                  ToString(entity.Coordinates) + ', ' +
                  ToString(entity.Finder) + ', ' +
                  ToString(entity.MinimapDots) + ', ' +
                  ToString(entity.Track) + ']';
end;
