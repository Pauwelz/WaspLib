

{$DEFINE WL_RSOBJECTS_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  EObjectData = enum(ID, NAME, TYP, CATEGORY, ACTIONS, COORDINATES, SIZE, ROTATIONS, COLORS);


  TRSObject = record
    UpText: TStringArray;
    Size: TVector3;
    Coordinates: TPointArray;
    LastCoordinate: TPoint;
    Rotations: TIntegerArray;
    Finder: TColorFinder;
    Track: Boolean;
    Walker: PRSWalker;
  end;


  TRSObjectArray = array of TRSObject;


function TRSObject.Create(walker: PRSWalker; size: TVector3; coordinates: TPointArray; uptext: TStringArray = []): TRSObject; static;
begin
  Result.Coordinates := coordinates;
  SetLength(Result.Rotations, Length(coordinates));
  Result.Size := size;
  if uptext <> [] then
    Result.UpText := uptext;
  Result.Walker := walker;
end;

function TRSObject.Create(json: TJSONObject): TRSObject; static; overload;
var
  i: Integer;
  colors: TColorArray;
  best: TBestColor;
begin
  if json.Typ <> EJSONType.OBJ then
    raise GetDebugLn('TRSObject', 'JSON Object expected, got ' + ToStr(json.Typ) + '.');

  with json.Item[Ord(EObjectData.NAME)] do
    if AsString <> 'null' then
      Result.UpText := [AsString];

  with json.Item[Ord(EObjectData.COORDINATES)] do
    for i := 0 to Count-1 do
      Result.Coordinates += [Item[i].Item[0].AsInt, Item[i].Item[1].AsInt];

  with json.Item[Ord(EObjectData.SIZE)] do
  begin
    Result.Size.X := Item[0].AsInt * 0.8;
    Result.Size.Y := Item[1].AsInt * 0.8;
    Result.Size.Z := Item[2].AsInt / 40;
  end;

  if Abs(Result.Size.Z) < 0.05 then
    Result.Size.Z := 3.0;

  with json.Item[Ord(EObjectData.ROTATIONS)] do
    for i := 0 to Count-1 do
      Result.Rotations += Item[i].AsInt;

  SetLength(Result.Rotations, Length(Result.Coordinates));

  with json.Item[Ord(EObjectData.ROTATIONS)] do
    for i := 0 to Count-1 do
      colors += Item[i].AsInt;

  if colors <> [] then
  begin
    best := GetBestColor(EColorSpace.HSV, colors);
    Result.Finder.Colors += [best.Color, best.Tolerance, EColorSpace.HSV, best.Mods];
  end;

  Result.Walker := @Map.Walker;
end;


function TRSObjectArray.Create(json: TJSONArray): TRSObjectArray; static;
var
  i: Integer;
begin
  if json.Typ <> EJSONType.ARR then
    raise GetDebugLn('TRSObject', 'JSON Array expected, got ' + ToStr(json.Typ) + '.');

  SetLength(Result, json.Count);
  for i := 0 to High(Result) do
    Result[i] := TRSObject.Create(json.Item[i]);
end;





function TRSObject._GetCuboid(me: TPoint; vector: TVector2; size: TVector3; height, radians, rotation: Single): TCuboid;
var
  corners: TVector3Array;
  pt: TPoint;
  arr: TPointArray;
begin
  pt := me + vector.ToPoint() - Minimap.Center;

  size.X := size.X*2;
  size.Y := size.Y*2;

  corners := [
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height],
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height+size.Z],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height+size.Z],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height+size.Z],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height+size.Z]
  ];

  arr := Projection.Run(corners, radians);
  Result := [
    [arr[4], arr[5], arr[6], arr[7]], [arr[0], arr[1], arr[2], arr[3]]
  ];

  Result.Bottom := Result.Bottom.Rotate(rotation);
  Result.Top := Result.Top.Rotate(rotation);
end;


function TRSObject.GetCuboidArray(me: TPoint; out coordinates: TPointArray; radians: Single = $FFFF): TCuboidArray;
var
  weights: TDoubleArray;
  meLocal, pt: TPoint;
  i: Integer;
  h, dist: Double;
  vector: TVector2;
begin
  coordinates := [];
  if radians = $FFFF then
    radians := Minimap.CompassRadians;

  meLocal := Self.Walker^.GetLocal(me);

  h := Self.Walker^.Height(meLocal - [1,3], False) + Self.Walker^.Height(meLocal + [3,-3], False) +
       Self.Walker^.Height(meLocal + [3,1], False) + Self.Walker^.Height(meLocal - [1,1], False);
  h := h/4;

  for i := 0 to High(Self.Coordinates) do
  begin
    pt := Self.Coordinates[i];
    dist := me.DistanceTo(pt);
    if dist > 85 then
      Continue;

    weights += dist;
    coordinates += pt;

    vector := Self.Walker^.Point2MMVec(me, pt, radians);
    pt := vector.ToPoint();
    vector := vector.Rotate(-radians, Minimap.Center);

    Result += Self._GetCuboid(meLocal, vector, Self.Size, h, radians, DegToRad(Self.Rotations[i]));
  end;

  if Result <> [] then
  begin
    Result.Sort(weights, True);
    coordinates.Sort(weights, True);
  end;
end;



function TRSObject.FindOnMainScreen(out coordinates: TPointArray; cuboidArray: TCuboidArray): T2DPointArray;
var
  i: Integer;
  found: TBooleanArray;
begin
  if Self.Finder <> Default(TColorFinder) then
  begin
    Self.Finder.FindEx(Result, found, cuboidArray);

    for i := High(found) downto 0 do
      if not found[i] then
        Delete(coordinates, i, 1);

    Exit;
  end;

  for i := 0 to High(cuboidArray) do
    Result += cuboidArray[i].ShapeFill();
end;


function TRSObject.FindEx(me: TPoint; out cuboids: TCuboidArray; out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
begin
  cuboids := Self.GetCuboidArray(me, coordinates);
  if cuboids = [] then Exit;
  atpa := Self.FindOnMainScreen(coordinates, cuboids);
  Result := atpa <> [];
end;



function TRSObject.Find(out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
var
  cuboids: TCuboidArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), cuboids, coordinates, atpa);
end;


function TRSObject.FindFrom(position: TPoint; out atpa: T2DPointArray): Boolean;
var
  cuboids: TCuboidArray; 
  coordinates: TPointArray;
begin
  Result := Self.FindEx(position, cuboids, coordinates, atpa);
end;


function TRSObject._UpTextCheck(out shouldExit: Boolean): Boolean;
var
  text: String;
begin
  shouldExit := True;

  if (RSClient.Mode = ERSMode.FIXED) and MSInterface.IsOpen() then
    Exit;

  if Self.UpText <> [] then
    Self.Walker^.TargetUpText := Copy(Self.UpText);

  text := MainScreen.UpText;

  if text.Contains('>') and not Self.Walker^.ActionUpText.Contains(['>']) then
  begin
    ChooseOption.Close();
    Exit;
  end;

  if not Self.UpText.IsEmpty and text.ContainsAny(Self.UpText) then
    Exit(True);

  shouldExit := False;
end;



function TRSObject.PreHover(me: TPoint; attempts: Integer = 2): Boolean;
var
  attempt: Integer;
  atpa: T2DPointArray;
begin
  for attempt := 0 to attempts do
  begin
    if not Self.FindFrom(me, atpa) then Continue;
    Mouse.Move(atpa.Random().Random());
    Exit(True);
  end;
end;



function TRSObject._ClickHelper(leftClick: Boolean): Boolean;
begin
  Self.Walker^.TargetUpText := [];
  Self.Walker^.ActionUpText := [];

  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Select(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
    Exit;
  end;

  if leftClick and Biometrics.RedClick(EMouseButton.LEFT, 2) then
    Exit(True);

  Result := not leftClick and (Self.UpText <> []) and ChooseOption.Select(Self.UpText);
end;


function TRSObject._SelectHelper(action: TStringArray): Boolean;
begin
  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() and ChooseOption.Select(action) then
    Exit(True);

  if MainScreen.IsUpText(action) then
    Exit(Biometrics.RedClick(EMouseButton.LEFT, 2));

  Result := ChooseOption.Select(action);
end;



function TRSObject.Hover(action: TStringArray = []; attempts: Integer = 2): Boolean;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  tpa: TPointArray;
  coordinates: TPointArray;
begin
  if ChooseOption.IsOpen() then
  begin
    if ((Self.UpText <> []) or (action <> [])) and ChooseOption.Find(Self.UpText + action) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.Walker = nil then
    raise GetDebugLn('TRSObject', 'Walker pointer missing.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSObject', 'Coordinates missing.');
  if Length(Self.Coordinates) <> Length(Self.Rotations) then
    raise GetDebugLn('TRSObject', 'Coordinates and Rotations don''t match.');

  //TODO:
  //if not Self.Walker^.MakePointVisible(Self.Coordinates) then Exit;

  Result := Self._UpTextCheck(shouldExit);
  if shouldExit then
    Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText + action) then Exit(True);

    if attempt <> (attempts - 1) then
      Continue;

    Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;


function TRSObject.WalkHover(action: TStringArray = []; attempts: Integer = 2): Boolean;
var
  me, closest: TPoint;
  coordinates, tpa: TPointArray;
  path: TGraphNodeArray;
  hasPath: Boolean;
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
begin
  if ChooseOption.IsOpen() then
  begin
    if ((Self.UpText <> []) or (action <> [])) then
      if ChooseOption.Find(Self.UpText + action) then
        Exit(True);
    ChooseOption.Close();
  end;

  me :=  Self.Walker^.Position();
  closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

  //if the point is not reachable with the webgraph (like a banker behind a booth) then pick nearest node as target
  if path = [] then
  begin
    path := Self.Walker^.WebGraph^.PathToNear(me, closest, 0.33);
    if path = [] then
      raise GetDebugLn('TRSObject', 'Can''t path to object.');
    hasPath := True;
  end;

  if Self.UpText <> [] then
    Self.Walker^.TargetUpText := Copy(Self.UpText);
  Self.Walker^.ActionUpText := action;

  //check if doors need to be passed to reach target
  if hasPath or Self.Walker^.WebGraph^.WalkableClusters.InSameTPA(me, closest) then
  begin
    if not Self.Walker^.MakePointVisible(closest) and not Self.Walker^.WebWalkEx(me, closest, 32, 0.33) then
      Exit;
  end
  else
  if not Self.Walker^.WebWalk(closest, 32, 0.33) then
    Exit;

  Result := Self._UpTextCheck(shouldExit) or Self.Walker^.RedClicked;
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then
        Exit(True);
      Sleep(50); //give uptext 1~ frame time to update
    end;

    if MainScreen.IsUpText(Self.UpText + action) then
      Exit(True);

    me := Self.Walker^.Position();
    closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

    if path = [] then
    begin
      path := Self.Walker^.WebGraph^.PathToNear(me, closest, 0.33);
      if path = [] then
        raise GetDebugLn('TRSObject', 'Can''t path to object.');
    end;

    if me.DistanceTo(closest) > 50 then
    begin
      Self.Walker^.WebWalkEx(me, closest, 30, 0.15);
      Continue;
    end;

    if attempt <> (attempts - 1) then Continue;

    if me.DistanceTo(closest) > 25 then
    begin
      Self.Walker^.WebWalkEx(me, closest, 25, 0.15);
      Continue;
    end;

    Minimap.CompassRadians := Minimap.CompassRadians + PI/3.6 * Random(-1,1);
  end;
end;



function TRSObject.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  Result := Self.Hover([], attempts) and Self._ClickHelper(leftClick);
end;


function TRSObject.Interact(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  Self.Walker^.ActionUpText := action;
  Result := Self.Hover(action, attempts) and Self._SelectHelper(action);
  Self.Walker^.TargetUpText := [];
  Self.Walker^.ActionUpText := [];
end;



function TRSObject.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSObject', 'Walker pointer missing.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSObject', 'Coordinates missing.');
  if Length(Self.Coordinates) <> Length(Self.Rotations) then
    raise GetDebugLn('TRSObject', 'Coordinates and Rotations don''t match.');

  Result := Self.WalkHover([], attempts) and Self._ClickHelper(leftClick);
  Self.Walker^.TargetUpText := [];
end;


function TRSObject.WalkInteract(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSObject', 'Walker pointer missing.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSObject', 'Coordinates missing.');
  if Length(Self.Coordinates) <> Length(Self.Rotations) then
    raise GetDebugLn('TRSObject', 'Coordinates and Rotations don''t match.');

  Result := Self.WalkHover(action, attempts);
  Result := Result and Self._SelectHelper(action);

  Self.Walker^.TargetUpText := [];
  Self.Walker^.ActionUpText := [];
end;



function TRSObject.DistanceTo(pt: TPoint): Double;
var
  dist: Double;
  i: Integer;
begin
  Result := $FFFFFF;
  for i := 0 to High(Self.Coordinates) do
  begin
    dist := Self.Coordinates[i].DistanceTo(pt);
    if dist < Result then
      Result := dist;
  end;
end;


function TRSObjectArray.ClosestIndex(pt: TPoint): Integer;
var
  closest, dist: Double;
  i, j: Integer;
begin
  closest := $FFFFFF;
  for i := 0 to High(Self) do
    for j := 0 to High(Self[i].Coordinates) do
    begin
      dist := Self[i].Coordinates[j].DistanceTo(pt);
      if dist >= closest then Continue;

      closest := dist;
      Result := i;
    end;
end;


procedure TImage.DrawObject(obj: TRSObject);
var
  atpa: T2DPointArray;
  cuboids: TCuboidArray;
  i: Integer;
  coordinates: TPointArray;
begin
  if not obj.FindEx(obj.Walker^.Position(), cuboids, coordinates, atpa) then Exit;

  Self.DrawColor := $00FFFF;
  for i := 0 to High(cuboids) do
  begin
    Self.DrawTPA(cuboids[i].Bottom.Corners.Connect().Grow(1));
    Self.DrawTPA(cuboids[i].Top.Corners.Connect().Grow(1));
  end;

  Self.DrawColor := TColor.Random();
  Self.DrawATPA(atpa);

  Self.DrawColor := $FFFFFF;
  for i := 0 to High(cuboids) do
    Self.DrawTPA(cuboids[i].Edges());
end;


procedure ShowOnTarget(obj: TRSObject); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  img.DrawObject(obj);
  img.Show();
end;


function ToString(constref obj: TRSObject): String; override;
begin
  Result := '[' + ToString(obj.UpText) + ', ' +
                  ToString(obj.Size) + ', ' +
                  ToString(obj.Coordinates) + ', ' +
                  ToString(obj.Rotations) + ', ' +
                  ToString(obj.Finder) + ', ' +
                  ToString(obj.Track) + ']';
end;
