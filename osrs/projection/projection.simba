

{$DEFINE WL_PROJECTION_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  EProjector = enum(CAMERA, MM2MS);

  TProjection = record
    System: EProjector;
    ZoomQuads: array [0..100] of TQuad;
    PlayerBoxes: array [0..100] of TBox;
    MM2MSProjector, MM2MSNormalizer: TMM2MS;
    CameraProjector, CameraNormalizer: TRSCamera;
    RENDER_DISTANCE: Integer;
  end;

procedure TProjection.Setup();
begin
  Self.CameraProjector.Setup();
  Self.CameraNormalizer.Setup();
  Self.CameraNormalizer.Update(50, 0);
  Self.MM2MSProjector.SetupProjection(RSClient.Mode);
  Self.MM2MSNormalizer.SetupProjection(ERSMode.FIXED);
  Self.MM2MSNormalizer.UpdateZoom(50);

  if Self.RENDER_DISTANCE = 0 then
    Self.RENDER_DISTANCE := 90;
end;


function TProjection.Run(arr: TVector3Array; roll: Single): TPointArray;
var
  i: Integer;
  normed: TVector3Array;
begin
  case Self.System of
    EProjector.CAMERA:
    begin
      Self.CameraProjector.Update(Options.GetZoomLevel(True), roll);
      Result := Self.CameraProjector.Run(arr);
    end;
    EProjector.MM2MS:
    begin
      with Minimap.Center do
        for i := 0 to High(arr) do
          normed += [arr[i].X - X, Y - arr[i].Y, arr[i].Z];
      Self.MM2MSProjector.UpdateZoom(Options.GetZoomLevel(True));
      Result := Self.MM2MSProjector.Run(normed, [0, 0, TAU - roll]).ToPoints();
    end;
  end;
end;

function TProjection.ReverseRun(arr: TVector3Array): TPointArray;
var
  v: TVector2;
begin
  case Self.System of
    EProjector.CAMERA:
    begin
      Self.CameraProjector.Update(Options.GetZoomLevel(True), Minimap.CompassRadians);
      Result := Self.CameraProjector.ReverseRun(arr);
    end;
    EProjector.MM2MS:
    begin
      Self.MM2MSProjector.UpdateZoom(Options.GetZoomLevel(True));
      with Minimap.Center do
        for v in Self.MM2MSProjector.InvertRun(arr, [0.0, 0.0, 0.0]) do
          Result += [Round(v.X) + X, Y - Round(v.Y)];
    end;
  end;
end;


var

  Projection: TProjection;


function TRSMinimap.Vectors2MS(vectors: TVector3Array; radians: Single): TPointArray;
var
  i: Integer;
begin
  for i := 0 to High(vectors) do
    with Self.NormalizeEx([vectors[i].X, vectors[i].Y], radians) do
    begin
      vectors[i].X := X;
      vectors[i].Y := Y;
    end;

  Result := Projection.Run(vectors, radians);
end;

function TRSMinimap.Vector2MS(vector: TVector3; radians: Single): TPoint;
begin
  with Self.NormalizeEx([vector.X, vector.Y], radians) do
    Result := Projection.Run([[X, Y, vector.Z]], radians)[0];
end;



function TRSMinimap.Points2MS(points: TPointArray; radians: Single = $FFFF): TPointArray;
var
  vectors: TVector3Array;
  i: Integer;
begin
  if radians = $FFFF then
    radians := Self.CompassRadians;

  SetLength(vectors, Length(points));

  for i := 0 to High(points) do
    with Self.Normalize(points[i], radians) do
    begin
      vectors[i].X := X;
      vectors[i].Y := Y;
    end;

  Result := Projection.Run(vectors, radians);
end;

function TRSMinimap.Point2MS(pt: TPoint; radians: Single = $FFFF): TPoint;
begin
  if radians = $FFFF then
    radians := Self.CompassRadians;
  with Self.Normalize(pt, radians) do
    Result := Projection.Run([[X, Y, 0]], radians)[0];
end;

function TRSMinimap.ATPA2MS(atpa: T2DPointArray; radians: Single = $FFFF): T2DPointArray; overload;
var
  tpa: TPointArray;
begin
  if radians = $FFFF then
    radians := Self.CompassRadians;
  for tpa in atpa do
    Result += Self.Points2MS(tpa, radians);
end;



function TRSMinimap.Vector2MSQuad(vector: TVector3; radians: Single; size: TVector2 = [1,1]; offset: TVector3 = [0,0,0]): TQuad;
var
  v1, v2: TVector2;
  arr: TPointArray;
begin
  size.X := 2 * size.X; size.Y := 2 * size.Y;
  vector.X += offset.X; vector.Y += offset.Y; vector.Z += offset.Z;

  with Self.NormalizeEx([vector.X, vector.Y], radians) do
  begin
    vector.X := X;
    vector.Y := Y;
  end;

  v1 := [vector.X-size.X, vector.Y-size.Y];
  v2 := [vector.X+size.X, vector.Y+size.Y];

  arr := Projection.Run([[v1.X, v1.Y, vector.Z],
                        [v2.X, v1.Y, vector.Z],
                        [v2.X, v2.Y, vector.Z],
                        [v1.X, v2.Y, vector.Z]], radians);

  Result := [arr[0], arr[1], arr[2], arr[3]];
end;

function TRSMinimap.Point2MSQuad(pt: TPoint; size: TVector2 = [1,1]; radians: Single = $FFFF): TQuad;
begin
  if radians = $FFFF then
    radians := Self.CompassRadians;
  Result := Self.Vector2MSQuad(pt.ToVec3(), radians, size);
end;



function TRSMinimap.Vector2MSCuboid(vector, size: TVector3; radians: Single; offset: TVector3 = [0,0,0]): TCuboid;
var
  v1, v2: TVector2;
  arr: TPointArray;
begin
  size.X := 2 * size.X;
  size.Y := 2 * size.Y;

  vector.X += offset.X;
  vector.Y += offset.Y;
  vector.Z += offset.Z;

  with Self.NormalizeEx([vector.X, vector.Y], radians) do
  begin
    vector.X := X;
    vector.Y := Y;
  end;

  v1 := [vector.X-size.X, vector.Y-size.Y];
  v2 := [vector.X+size.X, vector.Y+size.Y];

  arr := Projection.Run([
                [v1.X, v1.Y, vector.Z+size.Z], [v2.X, v1.Y, vector.Z+size.Z],
                [v2.X, v2.Y, vector.Z+size.Z], [v1.X, v2.Y, vector.Z+size.Z],

                [v1.X, v1.Y, vector.Z], [v2.X, v1.Y, vector.Z],
                [v2.X, v2.Y, vector.Z], [v1.X, v2.Y, vector.Z]
         ], radians);

  Result.Top := [arr[0], arr[1], arr[2], arr[3]];
  Result.Bottom := [arr[4], arr[5], arr[6], arr[7]];
end;

function TRSMinimap.Point2MSCuboid(pt: TPoint; size: TVector3; radians: Single = $FFFF): TCuboid;
begin
  if radians = $FFFF then
    radians := Self.CompassRadians;
  Result := Self.Vector2MSCuboid(pt.ToVec3(), size, radians);
end;



function TRSMainScreen.Point2MM(pt: TPoint; height: Single): TPoint;
begin
  Result := Projection.ReverseRun([[pt.X, pt.Y, height]])[0];
end;




property TRSMinimap.ZoomQuad: TQuad;
var
  tpa: TPointArray;
begin
  if Projection.ZoomQuads[Options.GetZoomLevel(True)] <> Default(TQuad) then
    Exit(Projection.ZoomQuads[Options.ZoomLevel]);

  tpa := Projection.ReverseRun([
           MainScreen.TopLeft.ToVec3(),
           MainScreen.TopRight.ToVec3(),
           MainScreen.BottomRight.ToVec3(),
           MainScreen.BottomLeft.ToVec3()
         ]);

  Result := [tpa[0],tpa[1],tpa[2],tpa[3]];

  Projection.ZoomQuads[Options.ZoomLevel] := Result;
end;


function TRSMinimap.PointOnZoomQuad(pt: TPoint): Boolean;
begin
  Result := Self.ZoomQuad.Contains(pt);
end;


function TRSMinimap.RandomPointOnZoomQuad(pt: TPoint; randomness: Integer): TPoint;
var
  quad: TQuad;
  img: TImage;
begin
  quad := Self.ZoomQuad;
  if not quad.Contains(pt) then
  begin
    img := Target.GetImage();
    img.DrawColor := $FFFFFF;
    img.DrawQuad(quad);
    img.DrawColor := $0000FF;
    img.DrawCross(pt, 4);
    img.Show();
    raise GetDebugLn('MM2MS', ToStr(pt) + ' is not a valid point to generate a random point on the zoom quad: ' + ToStr(quad) + '.');
  end;

  repeat
    Result := pt.Random(-randomness, randomness);
  until quad.Contains(Result);
end;



function TRSMinimap.FacePoint(pt: TPoint; randomness: Integer = 0): Boolean;
var
  quad: TQuad;
  tpa: TPointArray;
  distance: Double;
  i: Integer;
begin
  if not Self.Contains(pt) then Exit;

  quad := Self.ZoomQuad;
  if quad.Contains(pt) then Exit(True);

  tpa := quad.Corners.SortFrom(pt);
  distance := Self.Center.DistanceTo(pt);

  for i := 0 to High(tpa) do
  begin
    Result := distance <= Self.Center.DistanceTo(tpa[i]);
    if Result then
      Break;
  end;

  if not Result then
    Exit;

  Self.CompassDegrees := Self.Center.AngleBetween(tpa[i]) - Self.Center.AngleBetween(pt) + randomness;
end;


function TRSMainScreen.FacePoint(pt: TPoint; randomness: Integer = 0): Boolean;
begin
  Result := Minimap.FacePoint(Self.Point2MM(pt, 0.0), randomness);
end;


function TRSMainScreen.NormalizeDistance(dist: Integer): Integer;
var
  arr: TVector2Array;
begin
  if dist = 0 then Exit;
  case Projection.System of
    EProjector.CAMERA:
    begin
      Projection.CameraNormalizer.Update(Options.GetZoomLevel(True), 0);

      with MainScreen.Center do
        arr := Projection.CameraNormalizer.ReverseRunEx([[X,Y,0], [X,Y-dist,0]]);
      arr := Projection.CameraProjector.RunEx([arr[0].ToVec3(0), arr[1].ToVec3(0)]);
      Result := Round(arr[0].Distance(arr[1]));
    end;

    EProjector.MM2MS:
    begin
      Projection.MM2MSProjector.UpdateZoom(Options.GetZoomLevel(True));

      with MainScreen.Center do
        arr := Projection.MM2MSNormalizer.InvertRun([[X,Y,0], [X,Y-dist,0]], [0,0,0]);
      arr := Projection.MM2MSProjector.Run([arr[0].ToVec3(0), arr[1].ToVec3(0)], [0,0,0]);
      Result := Round(arr[0].Distance(arr[1]));
    end;
  end;
end;



function TRSMinimap.InZoomRangeEx(pt: TPoint; out corner: TPoint): Boolean;
var
  quad: TPointArray;
begin
  if not Self.Contains(pt) then Exit;

  quad := Self.ZoomQuad.Corners.SortFrom(Self.Center);
  corner := quad[High(quad)];

  Result := Self.Center.DistanceTo(pt) <= Self.Center.DistanceTo(corner);
end;

function TRSMinimap.InZoomRange(pt: TPoint): Boolean;
var
  corner: TPoint;
begin
  Result := Self.InZoomRangeEx(pt, corner);
end;

function TRSMinimap.AnyInZoomRange(tpa: TPointArray): Boolean; overload;
var
  quad: TPointArray;
  pt, corner: TPoint;
  dist: Double;
begin
  quad := Self.ZoomQuad.Corners.SortFrom(Self.Center);
  corner := quad[High(quad)];
  dist := Self.Center.DistanceTo(corner);

  for pt in tpa do
    if Self.Center.DistanceTo(pt) <= dist then
      Exit(True);
end;



function TRSMinimap.GetZoomToPoint(p: TPoint; randomness: Integer = 0): Integer;
var
  distance: Double;
begin
  distance := p.DistanceTo(Self.Center);

  Result := Round((73 - distance) / 0.8);
  Result := Result + randomness;
end;


function TRSMinimap.SetZoom2Point(pt: TPoint; randomness: Integer = 0): Boolean;
var
  level: Integer;
begin
  if Self.InZoomRange(pt) then Exit(True);

  level := Self.GetZoomToPoint(pt, randomness);

  if InRange(level, 0, 100) then
    Result := Options.SetZoomLevel(level);
end;



function TRSMinimap.MakePointVisible(pt: TPoint): Boolean;
begin
  Result := Self.SetZoom2Point(pt, Random(-5, 5)) and Self.FacePoint(pt, Random(-3, 3));
end;



procedure TRSMinimap.DebugTiles(img: TImage; dots: ERSMinimapDots);
const
  DOT_COLORS: TColorArray = [$FFFFFF, $00FFFF, $0000FF];
var
  pt: TPoint;
  vector: TVector3;
  quad: TQuad;
  dot: ERSMinimapDot;
  radians: Single;
  tpa: TPointArray;
begin
  radians := Self.CompassRadians;
  img.DrawColor := $00FF00;

  for pt.X := Self.Center.X - 120 to Self.Center.X + 120 with 4 do
    for pt.Y := Self.Center.Y - 120 to Self.Center.Y + 120 with 4 do
    begin
      //if not Self.PointOnZoomQuad(pt) then Continue;
      vector := pt.ToVec3().Rotate(radians, Self.Center);
      quad := Self.Vector2MSQuad(vector, radians, [1,1]);
      tpa += quad.Corners.Connect();
    end;

  img.DrawTPA(MainScreen.Filter(tpa));

  for dot in dots do
  begin
    tpa := [];
    for pt in Self.GetDots(dot) do
    begin
      vector := pt.ToVec3();
      if not Self.PointOnZoomQuad(vector.ToPoint()) then Continue;
      quad := Self.Vector2MSQuad(vector, radians, [1,1]);
      tpa += quad.Corners.Connect();
    end;

    img.DrawColor := DOT_COLORS[dot];
    img.DrawTPA(MainScreen.Filter(tpa));
  end;

  img.DrawColor := $FF0000;
  vector := Self.Center.ToVec3();
  quad := Self.Vector2MSQuad(vector, radians, [1,1]);
  tpa := quad.Corners.Connect();
  img.DrawTPA(tpa);
end;

procedure TRSMinimap.DebugTiles(dots: ERSMinimapDots = [ERSMinimapDot.PLAYER..ERSMinimapDot.ITEM]); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  Self.DebugTiles(img, dots);
  img.Show();
end;


property TRSMainScreen.PlayerBox: TBox;
var
  radians: Double;
  vectors: TVector3Array;
begin
  if Projection.PlayerBoxes[Options.GetZoomLevel()] <> [] then
    Exit(Projection.PlayerBoxes[Options.GetZoomLevel()]);

  radians := Minimap.CompassRadians;

  vectors := [
    Minimap.Center.Offset(-2,0).ToVec3(9).Rotate(-radians, Minimap.Center),
    Minimap.Center.Offset(2,0).ToVec3(-3).Rotate(-radians, Minimap.Center)
  ];

  Result := Projection.Run(vectors, radians).Bounds;
  Projection.PlayerBoxes[Options.GetZoomLevel()] := Result;
end;
