
{$DEFINE WL_ITEM_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

const

  QUANTITY_ALL = 0;
  QUANTITY_ALL_BUT_ONE = -1;

type

  ERSItemQuantity = enum(ONE, FIVE, TEN, CUSTOM, ALL);


function ERSItemQuantity.Integer2Quantity(quantity: Integer): ERSItemQuantity; static;
begin
  case quantity of
    1:     Result := ERSItemQuantity.ONE;
    5:     Result := ERSItemQuantity.FIVE;
    10:    Result := ERSItemQuantity.TEN;
    0, -1: Result := ERSItemQuantity.ALL;
    else   Result := ERSItemQuantity.CUSTOM;
  end;
end;

type

  ERSStack = enum(YELLOW, WHITE, GREEN);


property ERSStack.Color: TColor;
begin
  case Self of
    ERSStack.YELLOW: Result := $00FFFF;
    ERSStack.WHITE:  Result := $FFFFFF;
    ERSStack.GREEN:  Result := $80FF00;
  end;
end;


property ERSStack.Multiplier: Integer;
begin
  Result := Round(10 ** (3 * Ord(Self)));
end;


type

  TRSItem = String;

  TRSItemArray = array of TRSItem;


property TRSItem.Shadow: TColor; static;
begin
  Result := $202030;
end;


property TRSItem.ShadowGray: TColor; static;
begin
  Result := $333333;
end;



property TRSItem.BorderWhite: TColor; static;
begin
  Result := $FFFFFF;
end;


property TRSItem.Border: TColor; static;
begin
  Result := $010000;
end;



function TRSItem.InBounds(bounds: TBox; fadeTolerance: Single = 8.5): Boolean; static;
begin
  Result := Target.HasColor(TRSItem.Border, fadeTolerance, 1, bounds) or
            Target.HasColor(TRSItem.BorderWhite, 0, 1, bounds);
end;



function TRSItem.HasAmount(): Boolean;
begin
  Result := Self.EndsWith(')', True);
end;


function TRSItem.SimplifyName(): String;
var
  short, long: Integer;
begin
  if Self.Contains(' of ') then
    Result := Self.After(' of ').ToLower()
  else
    Result := Self.ToLower();

  if Result.EndsWith(')') then Result := Result.Before('(');

  long := Length(Result);
  short := Min(0, long - Ceil(long/3));
  Result := Result.CopyRange(0, Random(short, long));
end;


property TRSItem.StackBox(slot: TBox): TBox; static;
begin
  Result := [slot.X1, slot.Y1-1, slot.X1 + 35, slot.Y1 + 11];
end;



function TRSItem.ReadStack(slot: TBox): Integer; static;
var
  stack: ERSStack;
  color: TColor;
begin
  slot := TRSItem.StackBox[slot];

  for stack := Low(ERSStack) to High(ERSStack) do
  begin
    color := stack.Color;
    if Target.HasColor(color, 1, 1, slot) then
      Exit(OCR.RecognizeNumber(slot, RSFonts.PLAIN_11, [color], 1) * stack.Multiplier);
  end;

  if TRSItem.InBounds(slot, 0) then
    Exit;

  Result := -1;
end;

type

  TRSBankItem = object
    Item: TRSItem;
    Quantity: Integer;
    Noted: Boolean;
  end;


  TRSBankItemArray = array of TRSBankItem;


function TRSBankItem.Construct(item: TRSItem; quantity: Integer = QUANTITY_ALL_BUT_ONE): TRSBankItem; static;
begin
  Result := item.ToBankItem(quantity);
end;


function TRSItem.ToBankItem(quantity: Integer = QUANTITY_ALL_BUT_ONE): TRSBankItem;
begin
  Result.Quantity := quantity;
  Result.Noted := Self.StartsWith('Noted ', False);
  if Result.Noted then Result.Item := Self.After('Noted ')
  else Result.Item := Self;
end;


function TRSBankItem.ToItem(): TRSItem;
begin
  Result := Self.Item;
  if Self.Noted then
    Result := 'noted ' + Result.ToLower();
end;
