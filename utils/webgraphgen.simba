

{$DEFINE WL_WEBGRAPHGEN_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}
{$R-}

type

  TWebGraphGenerator = record
    Spacing, MinimumTiles, NodeRadius, MaxConnections,
    MaxDoorConnections: Integer;
    Skeletonize: Boolean;
    Disabled: Boolean;
  end;

function TWebGraphGenerator.Hash(): String;
var
  data: TIntegerArray;
begin
  data := [
    Self.Spacing, Self.MinimumTiles, Self.NodeRadius, Self.MaxConnections,
    Self.MaxDoorConnections, Int32(Self.Skeletonize)
  ];
  Result := HashData(EHashAlgo.CRC32, @data[0], Length(data));
end;


procedure TWebGraphGenerator.Setup(spacing, minimumTiles, nodeRadius, maxConnections, maxDoorConnections: Integer; skeletonize: Boolean);
begin
  Self.Spacing := spacing;
  Self.MinimumTiles := minimumTiles;
  Self.NodeRadius := nodeRadius;
  Self.MaxConnections := maxConnections;
  Self.MaxDoorConnections := maxDoorConnections;
  Self.Skeletonize := skeletonize;
end;

function TWebGraphGenerator.GetDoorDirection(center: TPoint; img: TImage): TPoint;
var
  imgBounds: TBox;
  
  function SafePixelCheck(x, y: Integer): Boolean;
  begin
    Result := imgBounds.Contains([x, y]) and (img.Pixel[x, y] = $0000FF);
  end;
  
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  
  if SafePixelCheck(center.X+1, center.Y) or SafePixelCheck(center.X-1, center.Y) then
    Exit([0,1]);

  if SafePixelCheck(center.X, center.Y+1) or SafePixelCheck(center.X, center.Y-1) then
    Exit([1,0]);

  if SafePixelCheck(center.X+1, center.Y+1) or SafePixelCheck(center.X-1, center.Y-1) then
    Exit([1,-1]);

  if SafePixelCheck(center.X+1, center.Y-1) or SafePixelCheck(center.X-1, center.Y+1) then
    Exit([1,1]);

  Result := [0,0];
end;

function TWebGraphGenerator.DoorIsSeparating(center, direction: TPoint; img: TImage): Boolean;
var
  inverted: TPoint;
  i: Integer;
  splitA, splitB: Boolean;
  testPoint: TPoint;
  imgBounds: TBox;
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  inverted := direction.Rotate(HALF_PI, [0,0]);

  for i := 1 to 5 do
  begin
    testPoint := Point(center.X, center.Y) + (inverted*i);
    
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(testPoint.X - direction.X, testPoint.Y - direction.Y);
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(center.X, center.Y) + (inverted*i) + direction;
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;
  end;

  for i := 1 to 5 do
  begin
    testPoint := Point(center.X, center.Y) - (inverted * i);
    
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(testPoint.X - direction.X, testPoint.Y - direction.Y);
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(center.X, center.Y) - (inverted * i) + direction;
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;
  end;

  Result := splitA and splitB;
end;


function TWebGraphGenerator.FindDoors(doors: T2DPointArray; img: TImage): T2DPointArray;
var
  direction: TPoint;
  i, idx: Integer;
  imgBounds: TBox;
  centerPt, testPt1, testPt2: TPoint;
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  
  for i := 0 to High(doors) do
  begin
    case Length(doors[i]) of
      4, 8: ;
      else Continue;
    end;

    centerPt := doors[i].Mean();
    direction := Self.GetDoorDirection(centerPt, img);
    if direction = [0,0] then Continue;

    testPt1 := Point(centerPt.X + direction.X, centerPt.Y + direction.Y);
    testPt2 := Point(centerPt.X - direction.X, centerPt.Y - direction.Y);
    
    if not imgBounds.Contains(testPt1) or not imgBounds.Contains(testPt2) then
      Continue;
      
    if (img.Pixel[testPt1.X, testPt1.Y] <> $FFFFFF) or
       (img.Pixel[testPt2.X, testPt2.Y] <> $FFFFFF) then
      Continue;

    if not Self.DoorIsSeparating(centerPt, direction, img) then
      Continue;

    idx := Length(Result);
    SetLength(Result, idx+1);
    Result[idx] += centerPt;
    Result[idx] += centerPt + direction * 2;
    Result[idx] += centerPt - direction * 2;
  end;
end;



function TWebGraphGenerator._BuildGraph(map: TImage; white, red: TPointArray): TWebGraph;
var
  i, j, l, n, hi, len, minLen, maxSpacing, minSpacing: Integer;
  clusters: T2DPointArray;
  skeleton, nodes, tpa, tmp: TPointArray;
  p, q: TPoint;
  tree: TKDPointTree;
  doors: T2DPointArray;
  connectMap: array of TIntegerMatrix;
  doorMapA, doorMapB, doorMap: TIntegerMatrix;
  skip, ignore: TBooleanArray;
  left, right: Boolean;
  connectA, connectB: TIntegerArray;
begin
  doors := Self.FindDoors(red.Cluster(1.5), map);

  SetLength(skip, Length(doors));
  SetLength(ignore, Length(doors));
  SetLength(connectA, Length(doors));
  SetLength(connectB, Length(doors));

  with white.Bounds() do
  begin
    SetLength(connectMap, Y2, X2);
    SetLength(doorMap, Y2, X2);
  end;

  minLen := Self.MinimumTiles * RSTranslator.TileArea;

  maxSpacing := Self.Spacing * 2;
  minSpacing := Self.Spacing div 2;

  clusters := white.Cluster(1);

  SetLength(doorMapA, Length(clusters));
  SetLength(doorMapB, Length(clusters));

  for i := 0 to High(clusters) do
  begin
    if Length(clusters[i]) < minLen then
      Continue;

    for j := 0 to High(doors) do
    begin
      if skip[j] or ignore[j] then Continue;
      left  := clusters[i].Contains(doors[j,1]);
      right := clusters[i].Contains(doors[j,2]);

      if left and right then
      begin
        ignore[j] := True;
        Continue;
      end;

      if left then
      begin
        connectA[j] := i;
        doorMapA[i] += j;
        skip[j] := connectB[j] <> 0;
      end
      else if right then
      begin
        connectB[j] := i;
        doorMapB[i] += j;
        skip[j] := connectA[j] <> 0;
      end
      else
        Continue;

      if not skip[j] then
      begin
        Result.Nodes += TGraphNode.Create(doors[j,0], EGraphNode.DOOR);
        doorMap[doors[j,0].Y, doors[j,0].X] := High(Result.Nodes);
        SetLength(Result.Paths, High(Result.Nodes));
      end;
    end;
  end;

  for i := 0 to High(clusters) do
  begin
    if Length(clusters[i]) < minLen then
      Continue;

    with clusters[i].Bounds() do
      if Max(Width, Height) < Self.NodeRadius then
      begin
        Result.Nodes += TGraphNode.Create(clusters[i].Median());
        hi := High(Result.Nodes);
        SetLength(Result.Paths, hi+1);

        for j in doorMapA[i] + doorMapB[i] do
          if not ignore[j] and ((connectA[j] = i) or (connectB[j] = i)) then
          begin
            l := doorMap[doors[j,0].Y, doors[j,0].X];
            ignore[j] := Result.Paths[l] <> [];
            Result.Paths[l] += [hi];
            Result.Paths[hi] += l;
          end;
        Continue;
      end;

    nodes := [];
    if Self.Skeletonize then
    begin
      skeleton := clusters[i].Erode(1).Skeleton(2, 6);
      for tpa in skeleton.Partition(Self.Spacing) do
        nodes += tpa.Cluster(1.5).Means();
    end
    else
    begin
      for tpa in clusters[i].Erode(1).Partition(Self.Spacing) do
        nodes += tpa.Cluster(1.5).Means();
    end;

    tree := TKDPointTree.Create(nodes);

    len := Length(Result.Nodes);
    SetLength(Result.Nodes, len + Length(nodes));
    SetLength(Result.Paths, Length(Result.Nodes));

    for j := 0 to High(tree.Data) do
    begin
      p := tree.Data[j].Split;
      for q in tree.KNearest(p, Self.MaxConnections*2, True) do
      begin
        if Max(Abs(p.X - q.X), Abs(p.Y - q.Y)) > maxSpacing then Continue;
        tpa := clusters[i].ExtractBox(TBox.Create(p, q).Expand(minSpacing));
        tpa := tpa.AStar(p, q, False);
        if (tpa = []) or (Length(tpa) > 80) then
          Continue;
        connectMap[q.Y,q.X] += j;
        if Inc(n) > Self.MaxConnections then
          Break;
      end;
      n := 0;
    end;

    for j := 0 to High(tree.Data) do
    begin
      p := tree.Data[j].Split;
      Result.Nodes[j+len] := TGraphNode.Create(p);
      for n in connectMap[p.Y,p.X] do
      begin
        q := tree.Data[n].Split;
        Result.Nodes[n+len] := TGraphNode.Create(q);

        if not Result.Paths[j+len].Contains(n+len) then
          Result.Paths[j+len] += n+len;
        if not Result.Paths[n+len].Contains(j+len) then
          Result.Paths[n+len] += j+len;
      end;
    end;

    for j in (doorMapA[i] + doorMapB[i]) do
    begin
      if ignore[j] then Continue;

      p := doors[j,0];
      l := doorMap[p.Y, p.X];

      tmp := clusters[i];
      tmp += p;

      for q in tree.KNearest(p, Self.MaxDoorConnections, True) do
      begin
        if Max(Abs(p.X - q.X), Abs(p.Y - q.Y)) > maxSpacing then
          Continue;

        tpa := tmp.ExtractBox(TBox.Create(p, q).Expand(minSpacing));
        tpa := tpa.AStar(p, q, False);
        if (tpa = []) or (Length(tpa) > 80) then
          Continue;

        n := Result.Nodes.IndexOf(q);
        Result.Paths[l] += [n];
        Result.Paths[n] += l;
      end;
    end;
  end;
end;

function TWebGraphGenerator.BuildGraph(name: String; map: TImage): TWebGraph;
var
  white, red, gray, merged, graySubset: TPointArray;
  whiteClusters, grayClusters, mergedClusters: T2DPointArray;
  i, j: Integer;
  t: UInt64;
begin
  white := map.FindColor($FFFFFF, 0);
  red := map.FindColor($0000FF, 0);

  WriteLn GetDebugLn('Generating webgraph for region: ' + name);

  t := GetTimeRunning();
  Result := Self._BuildGraph(map, white, red);

  gray := map.FindColor($333333, 0);

  whiteClusters := white.Cluster(1);
  grayClusters := gray.Cluster(1);

  for i := 0 to High(whiteClusters) do
  begin
    if Length(whiteClusters[i]) <= 6 then Continue;

    graySubset := gray.ExtractBox(whiteclusters[i].Bounds().Expand(80));
    merged := whiteclusters[i] + graySubset;
    mergedClusters := merged.Cluster(1);

    for j := 0 to high(mergedClusters) do
      if mergedClusters[j].Contains(whiteClusters[i][0]) then
      begin
        Result.WalkableClusters += mergedClusters[j];
        Break;
      end;
  end;

  Result.WalkableSpace    := white + gray;
  Result.ObjectClusters   := grayClusters;

  WriteLn GetDebugLn('WebGraphGenerator', 'Generating webgraph took ' + ToStr(Round(((GetTimeRunning()-t)/1000), 2)) + ' seconds.', ELogLevel.SUCCESS);
end;
{$R+}

var

  WebGraphGenerator: TWebGraphGenerator;
